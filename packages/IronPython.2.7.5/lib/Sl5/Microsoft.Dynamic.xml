<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Dynamic</name>
    </assembly>
    <members>
        <member name="M:Microsoft.Scripting.Actions.Calls.ActualArguments.TryBindNamedArguments(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.ArgumentBinding@,Microsoft.Scripting.Actions.Calls.CallFailure@)">
            <summary>
            Binds named arguments to the parameters. Returns a permutation of indices that captures the relationship between 
            named arguments and their corresponding parameters. Checks for duplicate and unbound named arguments.
            
            Ensures that for all i: namedArgs[i] binds to parameters[args.Length + bindingPermutation[i]] 
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.Count">
            <summary>
            The number of arguments not counting the collapsed ones.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.VisibleCount">
            <summary>
            Gets the total number of visible arguments passed to the call site including collapsed ones.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToExpression(Microsoft.Scripting.Actions.Calls.OverloadResolver,Microsoft.Scripting.Actions.Calls.RestrictedArguments,System.Boolean[])">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            If <c>null</c> is returned the argument is skipped (not passed to the callee).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.UpdateFromReturn(Microsoft.Scripting.Actions.Calls.OverloadResolver,Microsoft.Scripting.Actions.Calls.RestrictedArguments)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.  May
            return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToReturnExpression(Microsoft.Scripting.Actions.Calls.OverloadResolver)">
            <summary>
            If the argument produces a return value (e.g. a ref or out value) this provides
            the additional value to be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.ConsumedArgumentCount">
            <summary>
            The number of actual arguments consumed by this builder.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.Type">
            <summary>
            Returns the type required for the argument or null if the ArgBuilder
            does not consume a type.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.ByRefArgument">
            <summary>
            An assignable value that is passed to a byref parameter
            After the call it will contain the updated value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingResult">
            <summary>
            Indicates the specific type of failure, if any, from binding to a method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.Success">
            <summary>
            The binding succeeded.  Only one method was applicable or had the best conversion.  
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.AmbiguousMatch">
            <summary>
            More than one method was applicable for the provided parameters and no method was considered the best.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.IncorrectArgumentCount">
            <summary>
            There are no overloads that match the number of parameters required for the call
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.CallFailure">
            <summary>
            None of the target method(s) can successfully be called.  The failure can be due to:
                1. Arguments could not be successfully converted for the call
                2. Keyword arguments could not be assigned to positional arguments
                3. Keyword arguments could be assigned but would result in an argument being assigned 
                   multiple times (keyword and positional arguments conflit or dupliate keyword arguments).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.InvalidArguments">
            <summary>
            Actual arguments cannot be constructed.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.NoCallableMethod">
            <summary>
            No method is callable. For example, all methods have an unbound generic parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingTarget">
            <summary>
            Encapsulates the result of an attempt to bind to one or methods using the OverloadResolver.
            
            Users should first check the Result property to see if the binding was successful or
            to determine the specific type of failure that occured.  If the binding was successful
            MakeExpression can then be called to create an expression which calls the method.
            If the binding was a failure callers can then create a custom error message based upon
            the reason the call failed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.RestrictedArguments)">
            <summary>
            Creates a new BindingTarget when the method binding has succeeded.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,System.Int32[])">
            <summary>
            Creates a new BindingTarget when the method binding has failed due to an incorrect argument count
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.CallFailure[])">
            <summary>
            Creates a new BindingTarget when the method binding has failued due to 
            one or more parameters which could not be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodCandidate[])">
            <summary>
            Creates a new BindingTarget when the match was ambiguous
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,Microsoft.Scripting.Actions.Calls.BindingResult)">
            <summary>
            Other failure.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Result">
            <summary>
            Gets the result of the attempt to bind.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Method">
            <summary>
            Returns the method if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Overload">
            <summary>
            Returns the selected overload if the binding succeeded, or null if no one was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Name">
            <summary>
            Gets the name of the method as supplied to the OverloadResolver.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.MethodCandidate">
            <summary>
            Returns the MethodTarget if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.AmbiguousMatches">
            <summary>
            Returns the methods which don't have any matches or null if Result == BindingResult.AmbiguousMatch
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.CallFailures">
            <summary>
            Returns the methods and their associated conversion failures if Result == BindingResult.CallFailure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ExpectedArgumentCount">
            <summary>
            Returns the acceptable number of arguments which can be passed to the method if Result == BindingResult.IncorrectArgumentCount.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ActualArgumentCount">
            <summary>
            Returns the total number of arguments provided to the call. 0 if the call succeeded or failed for a reason other
            than argument count mismatch.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.RestrictedArguments">
            <summary>
            Gets the MetaObjects which we originally did binding against in their restricted form.
            
            The members of the array correspond to each of the arguments.  All members of the array
            have a value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ReturnType">
            <summary>
            Returns the return type of the binding, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.NarrowingLevel">
            <summary>
            Returns the NarrowingLevel of the method if the call succeeded.  If the call
            failed returns NarrowingLevel.None.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Success">
            <summary>
            Returns true if the binding was succesful, false if it failed.
            
            This is an alias for BindingTarget.Result == BindingResult.Success.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.CallFailure">
            <summary>
            Represents the reason why a call to a specific method could not be performed by the OverloadResolver.
            
            The reason for the failure is specified by the CallFailureReason property.  Once this property
            has been consulted the other properties can be consulted for more detailed information regarding
            the failure.
            
            If reason is ConversionFailure the ConversionResults property will be non-null.
            If reason is UnassignableKeyword the KeywordArguments property will be non-null and include
                the keywords which could not be assigned.
            If reason is DuplicateKeyword the KeywordArguments property will be non-null and include
                the keywords which were duplicated (either by the keywords themselves or by positional
                arguments).
                
            MethodTarget is always set and indicates the method which failed to bind.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Candidate">
            <summary>
            Gets the MethodTarget which the call failed for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Reason">
            <summary>
            Gets the reason for the call failure which determines the other 
            properties of the CallFailure which should be consulted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.ConversionResults">
            <summary>
            Gets a list of ConversionResult's for each parameter indicating
            whether the conversion was successful or failed and the types
            being converted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.KeywordArguments">
            <summary>
            Gets the list of keyword arguments that were either dupliated or
            unassignable.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.None">
            <summary>
            Default value, their was no CallFailure.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.ConversionFailure">
            <summary>
            One of more parameters failed to be converted
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.UnassignableKeyword">
            <summary>
            One or more keyword arguments could not be successfully assigned to a positional argument
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.DuplicateKeyword">
            <summary>
            One or more keyword arguments were duplicated or would have taken the spot of a 
            provided positional argument.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.TypeInference">
            <summary>
            Type arguments could not be inferred
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.CandidateSet">
            <summary>
            Represents a collection of MethodCandidate's which all accept the
            same number of logical parameters.  For example a params method
            and a method with 3 parameters would both be a CandidateSet for 3 parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ConversionResult">
            <summary>
            Represents information about a failure to convert an argument from one
            type to another.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ConversionResult.Arg">
            <summary>
            Value of the argument or null if it is not available.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ConversionResult.ArgType">
            <summary>
            Argument actual type or its limit type if the value not known.
            DynamicNull if the argument value is null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.DefaultArgBuilder">
            <summary>
            ArgBuilder which provides a default parameter value for a method call.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OverloadResolver">
            <summary>
            Provides binding and overload resolution to .NET methods.
            
            MethodBinder's can be used for:
                generating new AST code for calling a method 
                calling a method via reflection at runtime
                (not implemented) performing an abstract call
                
            MethodBinder's support default arguments, optional arguments, by-ref (in and out), and keyword arguments.
            
            Implementation Details:
            
            The MethodBinder works by building up a CandidateSet for each number of effective arguments that can be
            passed to a set of overloads.  For example a set of overloads such as:
                foo(object a, object b, object c)
                foo(int a, int b)
                
            would have 2 target sets - one for 3 parameters and one for 2 parameters.  For parameter arrays
            we fallback and create the appropriately sized CandidateSet on demand.
            
            Each CandidateSet consists of a set of MethodCandidate's.  Each MethodCandidate knows the flattened
            parameters that could be received.  For example for a function such as:
                foo(params int[] args)
                
            When this method is in a CandidateSet of size 3 the MethodCandidate takes 3 parameters - all of them
            ints; if it's in a CandidateSet of size 4 it takes 4 parameters.  Effectively a MethodCandidate is 
            a simplified view that allows all arguments to be treated as required positional arguments.
            
            Each MethodCandidate in turn refers to a MethodTarget.  The MethodTarget is composed of a set
            of ArgBuilder's and a ReturnBuilder which know how to consume the positional arguments and pass
            them to the appropriate argument of the destination method.  This includes routing keyword
            arguments to the correct position, providing the default values for optional arguments, etc...
            
            After binding is finished the MethodCandidates are thrown away and a BindingTarget is returned. 
            The BindingTarget indicates whether the binding was successful and if not any additional information
            that should be reported to the user about the failed binding.  It also exposes the MethodTarget which
            allows consumers to get the flattened list of required parameters for the call.  MethodCandidates
            are not exposed and are an internal implementation detail of the MethodBinder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.ResolveOverload(System.String,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Resolves a method overload and returns back a BindingTarget.
            
            The BindingTarget can then be tested for the success or particular type of
            failure that prevents the method from being called. If successfully bound the BindingTarget
            contains a list of argument meta-objects with additional restrictions that ensure the selection
            of the particular overload.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.AllowMemberInitialization(Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Checks to see if the language allows named arguments to be bound to instance fields or
            properties and turned into setters. By default this is only allowed on contructors.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.GetByRefArrayExpression(System.Linq.Expressions.Expression)">
            <summary>
            Gets an expression that evaluates to the result of GetByRefArray operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.BindToUnexpandedParams(Microsoft.Scripting.Actions.Calls.MethodCandidate)">
            <summary>
            Allow to bind an array/dictionary instance or a null reference to params array/dictionary parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.MapSpecialParameters(Microsoft.Scripting.Actions.Calls.ParameterMapping)">
            <summary>
            Called before arguments binding.
            </summary>
            <returns>
            A bitmask that indicates (set bits) the parameters that were mapped by this method.
            A default mapping will be constructed for the remaining parameters (cleared bits).
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.CreateActualArguments(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject},System.Collections.Generic.IList{System.String},System.Int32,System.Int32)">
            <summary>
            Return null if arguments cannot be constructed and overload resolution should produce an error.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.IsOverloadedOnParameter(System.Int32,System.Int32,System.Collections.Generic.IList{Microsoft.Scripting.Actions.Calls.ApplicableCandidate})">
            <summary>
            Determines whether given overloads are overloaded on index-th parameter (the types of the index-th parameters are the same).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.SelectBestConversionFor(System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Selects the best (of two) candidates for conversion from actualType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.GetSplattedItemExpression(System.Linq.Expressions.Expression)">
            <summary>
            The method is called each time an item of lazily splatted argument is needed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.InstanceBuilder.ConsumedArgumentCount">
            <summary>
            The number of actual arguments consumed by this builder.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder">
            <summary>
            ArgBuilder which provides a value for a keyword argument.  
            
            The KeywordArgBuilder calculates its position at emit time using it's initial 
            offset within the keyword arguments, the number of keyword arguments, and the 
            total number of arguments provided by the user.  It then delegates to an 
            underlying ArgBuilder which only receives the single correct argument.
            
            Delaying the calculation of the position to emit time allows the method binding to be 
            done without knowing the exact the number of arguments provided by the user. Hence,
            the method binder can be dependent only on the set of method overloads and keyword names,
            but not the user arguments. While the number of user arguments could be determined
            upfront, the current MethodBinder does not have this design.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder.BuilderExpectsSingleParameter(Microsoft.Scripting.Actions.Calls.ArgBuilder)">
            <summary>
            The underlying builder should expect a single parameter as KeywordArgBuilder is responsible
            for calculating the correct parameter to use
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordConstructorReturnBuilder">
            <summary>
            Updates fields/properties of the returned value with unused keyword parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodCandidate">
             <summary>
             MethodCandidate represents the different possible ways of calling a method or a set of method overloads.
             A single method can result in multiple MethodCandidates. Some reasons include:
             - Every optional parameter or parameter with a default value will result in a candidate
             - The presence of ref and out parameters will add a candidate for languages which want to return the updated values as return values.
             - ArgumentKind.List and ArgumentKind.Dictionary can result in a new candidate per invocation since the list might be different every time.
            
             Each MethodCandidate represents the parameter type for the candidate using ParameterWrapper.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodCandidate.MakeParamsExtended(System.Int32,System.Collections.Generic.IList{System.String})">
            <summary>
            Builds a new MethodCandidate which takes count arguments and the provided list of keyword arguments.
            
            The basic idea here is to figure out which parameters map to params or a dictionary params and
            fill in those spots w/ extra ParameterWrapper's.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.NarrowingLevel">
            <summary>
            Narrowing conversions are conversions that cannot be proved to always succeed, conversions that are 
            known to possibly lose information, and conversions across domains of types sufficiently different 
            to merit narrowing notation like casts. 
            
            Its upto every language to define the levels for conversions. The narrowling levels can be used by
            for method overload resolution, where the overload is based on the parameter types (and not the number 
            of parameters).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.None">
            <summary>
            Conversions at this level do not do any narrowing. Typically, this will include
            implicit numeric conversions, Type.IsAssignableFrom, StringBuilder to string, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.One">
            <summary>
            Language defined prefered narrowing conversion.  First level that introduces narrowing
            conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Two">
            <summary>
            Language defined preferred narrowing conversion.  Second level that introduces narrowing
            conversions and should have more conversions than One.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Three">
            <summary>
            Language defined preferred narrowing conversion.  Third level that introduces narrowing
            conversions and should have more conversions that Two.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.All">
            <summary>
            A somewhat meaningful conversion is possible, but it will quite likely be lossy.
            For eg. BigInteger to an Int32, Boolean to Int32, one-char string to a char,
            larger number type to a smaller numeric type (where there is no overflow), etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OutArgBuilder">
            <summary>
            Builds the argument for an out argument when not passed a StrongBox.  The out parameter
            is returned as an additional return value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OverloadInfo">
            <summary>
            Defines a method overload abstraction for the purpose of overload resolution. 
            It provides the overload resolver the metadata it needs to perform the resolution.
            </summary>
            <remarks>
            WARNING: This is a temporary API that will undergo breaking changes in future versions.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.OverloadInfo.ReturnParameter">
            <summary>
            Null for constructors.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.OverloadInfo.IsVariadic">
            <summary>
            The method arity can vary, i.e. the method has params array or params dict parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReflectionOverloadInfo">
            <summary>
            Represents a method overload that is bound to a <see cref="T:System.Reflection.MethodBase"/>.
            </summary>
            <remarks>
            Not thread safe.
            WARNING: This is a temporary API that will undergo breaking changes in future versions. 
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterMapping.MapParameterReduceByRef(System.Reflection.ParameterInfo)">
            <summary>
            Maps out parameters to return args and ref parameters to ones that don't accept StrongBox.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParameterWrapper">
            <summary>
            ParameterWrapper represents the logical view of a parameter. For eg. the byref-reduced signature
            of a method with byref parameters will be represented using a ParameterWrapper of the underlying
            element type, since the logical view of the byref-reduced signature is that the argument will be
            passed by value (and the updated value is included in the return value).
            
            Contrast this with ArgBuilder which represents the real physical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterWrapper.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            ParameterInfo is not available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterWrapper.Expand">
            <summary>
            Creates a parameter that represents an expanded item of params-array.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ParameterWrapper.IsParamsArray">
            <summary>
            True if the wrapper represents a params-array parameter (false for parameters created by expansion of a params-array).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ParameterWrapper.IsParamsDict">
            <summary>
            True if the wrapper represents a params-dict parameter (false for parameters created by expansion of a params-dict).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParamsDictArgBuilder">
            <summary>
            Builds the parameter for a params dictionary argument - this collects all the extra name/value
            pairs provided to the function into a SymbolDictionary which is passed to the function.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReferenceArgBuilder">
            <summary>
            An argument that the user wants to explicitly pass by-reference (with copy-in copy-out semantics).
            The user passes a StrongBox[T] object whose value will get updated when the call returns.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Type,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Parameter info is not available for this argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Reflection.ParameterInfo,System.Int32)">
            <summary>
            Type and whether the parameter is a params-array or params-dictionary is derived from info.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.RestrictedArguments.HasUntypedRestrictions">
            <summary>
            True if there are restrictions beyond just simple type restrictions
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReturnReferenceArgBuilder">
            <summary>
            Builds a parameter for a reference argument when a StrongBox has not been provided.  The
            updated return value is returned as one of the resulting return values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetGenericArgumentsForInferedMethod(Microsoft.Scripting.Actions.Calls.OverloadInfo,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Gets the generic arguments for method based upon the constraints discovered during
            type inference.  Returns null if not all generic arguments had their types inferred.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CreateNewArgBuilders(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Creates a new set of arg builders for the given generic method definition which target the new
            parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CreateNewWrappers(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.OverloadInfo,Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Creates a new list of ParameterWrappers for the generic method replacing the old parameters with the new ones.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetSortedGenericArguments(Microsoft.Scripting.Actions.Calls.OverloadInfo,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{System.Type}})">
            <summary>
            Gets the generic type arguments sorted so that the type arguments
            that are depended upon by other type arguments are sorted before
            their dependencies.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.IsDependentConstraint(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{System.Type}},System.Type,System.Type)">
            <summary>
            Checks to see if the x type parameter is dependent upon the y type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetDependencyMapping(Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Builds a mapping based upon generic parameter constraints between related generic
            parameters.  This is then used to sort the generic parameters so that we can process
            the least dependent parameters first.  For example given the method:
            
            void Foo{T0, T1}(T0 x, T1 y) where T0 : T1 
            
            We need to first infer the type information for T1 before we infer the type information
            for T0 so that we can ensure the constraints are correct.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetArgumentToInputMapping(Microsoft.Scripting.Actions.Calls.MethodCandidate,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Returns a mapping from generic type parameter to the input DMOs which map to it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.AddOneInput(System.Collections.Generic.Dictionary{System.Type,Microsoft.Scripting.Actions.Calls.TypeInferer.ArgumentInputs},System.Dynamic.DynamicMetaObject,System.Type)">
            <summary>
            Adds any additional ArgumentInputs entries for the given object and parameter type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CollectGenericParameters(System.Type,System.Collections.Generic.List{System.Type})">
            <summary>
            Walks the nested generic hierarchy to construct all of the generic parameters referred
            to by this type.  For example if getting the generic parameters for the x parameter on
            the method:
            
            void Foo{T0, T1}(Dictionary{T0, T1} x);
            
            We would add both typeof(T0) and typeof(T1) to the list of generic arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetInferedType(Microsoft.Scripting.Actions.Calls.OverloadResolver,System.Type,System.Type,System.Dynamic.DynamicMetaObject,System.Collections.Generic.Dictionary{System.Type,System.Type},System.Collections.Generic.Dictionary{System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions})">
            <summary>
            Provides generic type inference for a single parameter.
            </summary>
            <remarks>
            For example: 
              M{T}(T x)
              M{T}(IList{T} x)
              M{T}(ref T x)
              M{T}(T[] x)
              M{T}(ref Dictionary{T,T}[] x)
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetInferedType(System.Type,System.Type,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Provides generic type inference for a single parameter.
            </summary>
            <remarks>
            For example: 
              M{T}(T x)
              M{T}(IList{T} x)
              M{T}(ref T x)
              M{T}(T[] x)
              M{T}(ref Dictionary{T,T}[] x)
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.ConstraintsViolated(System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Checks if the constraints are violated by the given input for the specified generic method parameter.
            
            This method must be supplied with a mapping for any dependent generic method type parameters which
            this one can be constrained to.  For example for the signature "void Foo{T0, T1}(T0 x, T1 y) where T0 : T1".
            we cannot know if the constraints are violated unless we know what we have calculated T1 to be.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.MatchGenericParameter(System.Type,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type},System.Type@)">
            <summary>
            Finds all occurences of <c>genericParameter</c> in <c>openType</c> and the corresponding concrete types in <c>closedType</c>.
            Returns true iff all occurences of the generic parameter in the open type correspond to the same concrete type in the closed type 
            and this type satisfies given <c>constraints</c>. Returns the concrete type in <c>match</c> if so.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.TypeInferer.ArgumentInputs">
            <summary>
            Maps a single type parameter to the possible parameters and DynamicMetaObjects
            we can get inference from.  For example for the signature:
            
            void Foo{T0, T1}(T0 x, T1 y, IList{T1} z);
            
            We would have one ArgumentInput for T0 which holds onto the DMO providing the argument
            value for x.  We would also have one ArgumentInput for T1 which holds onto the 2 DMOs
            for y and z.  Associated with y would be a GenericParameterInferer and associated with
            z would be a ConstructedParameterInferer.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.IInferableInvokable">
            <summary>
            Implemented by DynamicMetaObject subclasses when the associated object
            can participate in generic method type inference.  This interface
            is used when the inference engine is attempting to perform type inference
            for a parameter which is typed to a delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.IInferableInvokable.GetInferredType(System.Type,System.Type)">
            <summary>
            Returns the type inferred for parameterType when performing
            inference for a conversion to delegateType.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.InferenceResult">
            <summary>
            Provides information about the result of a custom object which dynamically
            infers back types.
            
            Currently only used for invokable objects to feedback the types for a delegate
            type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConversionResultKind">
            <summary>
            Determines the result of a conversion action.  The result can either result in an exception, a value that
            has been successfully converted or default(T), or a true/false result indicating if the value can be converted.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitCast">
            <summary>
            Attempts to perform available implicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitCast">
            <summary>
            Attempst to perform available implicit and explicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitTry">
            <summary>
            Attempts to perform available implicit conversions and returns default(ReturnType) if no conversions can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ImplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitTry">
            <summary>
            Attempts to perform available implicit and explicit conversions and returns default(ReturnType) if no conversions 
            can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ExplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ActionBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.Convert(System.Object,System.Type)">
            <summary>
            Converts an object at runtime into the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.CanConvertFrom(System.Type,System.Type,System.Boolean,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Determines if a conversion exists from fromType to toType at the specified narrowing level.
            toNotNullable is true if the target variable doesn't allow null values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ConvertExpression(System.Linq.Expressions.Expression,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Converts the provided expression to the given type.  The expression is safe to evaluate multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetMember(Microsoft.Scripting.Actions.MemberRequestKind,System.Type,System.String)">
            <summary>
            Gets the members that are visible from the provided type of the specified name.
            
            The default implemetnation first searches the type, then the flattened heirachy of the type, and then
            registered extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticAssignFromDerivedTypeError(System.Type,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.MemberTracker,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Called when a set is attempting to assign to a field or property from a derived class through the base class.
            
            The default behavior is to allow the assignment.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticPropertyInstanceAccessError(Microsoft.Scripting.Actions.PropertyTracker,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Creates an ErrorInfo object when a static property is accessed from an instance member.  The default behavior is throw
            an exception indicating that static members properties be accessed via an instance.  Languages can override this to 
            customize the exception, message, or to produce an ErrorInfo object which reads or writes to the property being accessed.
            </summary>
            <param name="tracker">The static property being accessed through an instance</param>
            <param name="isAssignment">True if the user is assigning to the property, false if the user is reading from the property</param>
            <param name="parameters">The parameters being used to access the property.  This includes the instance as the first entry, any index parameters, and the
            value being assigned as the last entry if isAssignment is true.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeMissingMemberError(System.Type,System.Dynamic.DynamicMetaObject,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            
            Deprecated, use the non-generic version instead
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetAllExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Base classes are also
            searched for their extension members.  Once any of the types in the inheritance hierarchy
            provide an extension member the search is stopped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Subclasses of the
            type and their extension members are not searched.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ReturnMemberTracker(System.Type,Microsoft.Scripting.Actions.MemberTracker)">
            <summary>
            Provides an opportunity for languages to replace all MemberTracker's with their own type.
            
            Alternatlely a language can expose MemberTracker's directly.
            </summary>
            <param name="memberTracker">The member which is being returned to the user.</param>
            <param name="type">Tthe type which the memberTrack was accessed from</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ActionBinder.PrivateBinding">
            <summary>
            Determines if the binder should allow access to non-public members.
            
            By default the binder does not allow access to non-public members.  Base classes
            can inherit and override this value to customize whether or not private binding
            is available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetIndex(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetIndex(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeGeneralOperatorRule(System.String,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the meta object for the rest of the operations: comparisons and all other
            ExpressionType.  If the operation cannot be completed a MetaObject which indicates an
            error will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeGeneralOperatorRule(System.Linq.Expressions.ExpressionType,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the meta object for the rest of the operations: comparisons and all other
            ExpressionType.  If the operation cannot be completed a MetaObject which indicates an
            error will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullComparisonRule(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Produces a rule for comparing a value to null - supports comparing object references and nullable types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryConvertToObject(System.Type,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions)">
            <summary>
            Checks if the conversion is to object and produces a target if it is.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAllConversions(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if any conversions are available and if so builds the target for that conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAssignableConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by a simple cast.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by calling a user-defined conversion method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryOneConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,System.Type,System.String,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper that checkes both types to see if either one defines the specified conversion
            method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,Microsoft.Scripting.Actions.MemberGroup,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if any of the members of the MemberGroup provide the applicable conversion and 
            if so uses it to build a conversion rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryExtensibleConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion is to applicable by extracting the value from Extensible of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryImplicitNumericConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if there's an implicit numeric conversion for primitive data types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullableConversion(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if there's a conversion to/from Nullable of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Checks to see if there's a conversion of null to a reference type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeErrorTarget(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce an error when a conversion cannot occur
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeBoxingTarget(System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions)">
            <summary>
            Helper to produce a rule which just boxes a value type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTargetWorker(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Boolean,System.Dynamic.BindingRestrictions,System.Linq.Expressions.Expression)">
            <summary>
            Helper to produce a conversion rule by calling the method to do the convert.  This version takes the parameter
            to be passed to the conversion function and we call it w/ our own value or w/ our Extensible.Value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.WrapForThrowingTry(Microsoft.Scripting.Actions.ConversionResultKind,System.Boolean,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Helper to wrap explicit conversion call into try/catch incase it throws an exception.  If
            it throws the default value is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleConversionTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required (the strong type of the expression
            input matches the type we're converting to or has an implicit conversion at the IL level)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleExtensibleConversionTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required from an extensible type's
            underlying storage to the type we're converting to.  The type of extensible type
            matches the type we're converting to or has an implicit conversion at the IL level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to extract the value from an Extensible of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullToNullableOfTTarget(System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Helper to convert a null value to nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeTToNullableOfTTarget(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConvertingToTToNullableOfTTarget(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetExtensibleValue(System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to extract the Value of an Extensible of T from the
            expression being converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetUnderlyingType(System.Type)">
            <summary>
            Helper that checks if fromType is an Extensible of T or a subtype of 
            Extensible of T and if so returns the T.  Otherwise it returns fromType.
            
            This is used to treat extensible types the same as their underlying types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullTarget(System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Creates a target which returns null for a reference type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorDeleteMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the GetMember.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Boolean,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="resolverFactory">
            An OverloadResolverFactory which can be used for performing overload resolution and method binding.
            </param>
            <param name="isNoThrow">
            True if the operation should return Operation.Failed on failure, false if it
            should return the exception produced by MakeMissingMemberError.
            </param>
            <param name="errorSuggestion">
            The meta object to be used if the get results in an error.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,System.Boolean,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="isNoThrow">
            True if the operation should return Operation.Failed on failure, false if it
            should return the exception produced by MakeMissingMemberError.
            </param>
            <param name="errorSuggestion">
            The meta object to be used if the get results in an error.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorGetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <param name="resolverFactory">Overload resolver factory.</param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <param name="resolverFactory">Overload resolver factory.</param>
            <param name="errorSuggestion">The result should the object be uncallable.</param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTargetInfo(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets a TargetInfo object for performing a call on this object.  
            
            If this object is a delegate we bind to the Invoke method.
            If this object is a MemberGroup or MethodGroup we bind to the methods in the member group.
            If this object is a BoundMemberTracker we bind to the methods with the bound instance.
            If the underlying type has defined an operator Call method we'll bind to that method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMethodGroupTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.MethodGroup)">
            <summary>
            Binds to the methods in a method group.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMemberGroupTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.MemberGroup)">
            <summary>
            Binds to the methods in a member group.  
            
            TODO: We should really only have either MemberGroup or MethodGroup, not both.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetBoundMemberTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.BoundMemberTracker)">
            <summary>
            Binds to the BoundMemberTracker and uses the instance in the tracker and restricts
            based upon the object instance type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetDelegateTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Delegate)">
            <summary>
            Binds to the Invoke method on a delegate if this is a delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetOperatorTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Object)">
            <summary>
            Attempts to bind to an operator Call method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase})">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions,System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions,System.String,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="minLevel">TODO.</param>
            <param name="maxLevel">TODO.</param>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSplatTests(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Makes test for param arrays and param dictionary parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsArrayTest(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Pulls out the right argument to build the splat test.  MakeParamsTest makes the actual test.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsTest(System.Dynamic.DynamicMetaObject,System.Boolean)">
            <summary>
            Builds the restrictions for calling with a splatted argument array.  Ensures that the
            argument is still an ICollection of object and that it has the same number of arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsDictionaryTest(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject},System.Boolean)">
            <summary>
            Builds the restrictions for calling with keyword arguments.  The restrictions include
            tests on the individual keys of the dictionary to ensure they have the same names.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the SetMember.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="errorSuggestion">
            Provides a DynamicMetaObject that is to be used as the result if the member cannot be set.  If null then then a language
            specific error code is provided by ActionBinder.MakeMissingMemberErrorForAssign which can be overridden by the language.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the SetMember.
            </param>
            <param name="errorSuggestion">
            Provides a DynamicMetaObject that is to be used as the result if the member cannot be set.  If null then then a language
            specific error code is provided by ActionBinder.MakeMissingMemberErrorForAssign which can be overridden by the language.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorSetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeUndeletableMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNonPublicMemberGetError(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.MemberTracker,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Called when the user is accessing a protected or private member on a get.
            
            The default implementation allows access to the fields or properties using reflection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeReadOnlyMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.TargetInfo">
            <summary>
            Encapsulates information about the target of the call.  This includes an implicit instance for the call,
            the methods that we'll be calling as well as any restrictions required to perform the call.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorMetaObject">
            <summary>
            A MetaObject which was produced as the result of a failed binding.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Interceptor">
            <summary>
            Interceptor prototype. The interceptor is a call site binder that wraps
            a real call site binder and can perform arbitrary operations on the expression
            trees that the wrapped binder produces:
              * Dumping the trees
              * Additional rewriting
              * Static compilation
              * ...
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DynamicSiteHelpers.IsInvisibleDlrStackFrame(System.Reflection.MethodBase)">
            <summary>
            Returns true if the method should not be displayed in the stack frame.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberRequestKind">
            <summary>
            Specifies the action for which the default binder is requesting a member.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ExpressionCollectionBuilder`1.Expressions">
            <summary>
            If the number of items added to the builder is greater than 4 returns a read-only collection builder containing all the items.
            Returns <c>null</c> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.BlockBuilder.ToExpression">
            <summary>
            Returns <c>null</c> if no expression was added into the builder.
            If only a single expression was added returns it.
            Otherwise returns a <see cref="T:System.Linq.Expressions.BlockExpression"/> containing the expressions added to the builder.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FinallyFlowControlExpression">
            <summary>
            Wrapping a tree in this node enables jumps from finally blocks
            It does this by generating control-flow logic in the tree
            
            Reducing this node requires a full tree walk of its body
            (but not nested lambdas)
            
            WARNING: this node cannot contain jumps across blocks, because it
            assumes any unknown jumps are jumps to an outer scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Utils">
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.IsAssignment(System.Linq.Expressions.ExpressionType)">
            <summary>
            Determines whether specified expression type represents an assignment.
            </summary>
            <returns>
            True if the expression type represents an assignment.
            </returns>
            <remarks>
            Note that some other nodes can also assign to variables, members or array items:
            MemberInit, NewArrayInit, Call with ref params, New with ref params, Dynamic with ref params.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.GetLValueAccess(System.Linq.Expressions.ExpressionType)">
            <summary>
            Determines if the left child of the given expression is read or written to or both.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Void(System.Linq.Expressions.Expression)">
            <summary>
            Converts an expression to a void type.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression"/> to convert to void. </param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType"/> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked"/> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand"/> and <see cref="P:System.Linq.Expressions.Expression.Type"/> property set to void.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Box(System.Linq.Expressions.Expression)">
            <summary>
            Returns an expression that boxes a given value. Uses boxed objects cache for Int32 and Boolean types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Generator(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
            <summary>
            Creates a generator with type IEnumerable{T}, where T is the label.Type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.TransformEnumerable(System.Linq.Expressions.Expression,System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression})">
            
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            Null coalescing expression
            {result} ::= ((tmp = {_left}) == null) ? {right} : tmp
            '??' operator in C#.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(Microsoft.Scripting.Ast.LambdaBuilder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(Microsoft.Scripting.Ast.LambdaBuilder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.WeakConstant(System.Object)">
            <summary>
            Wraps the given value in a WeakReference and returns a tree that will retrieve
            the value from the WeakReference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Lambda(System.Type,System.String)">
            <summary>
            Creates new instance of the LambdaBuilder with the specified name and return type.
            </summary>
            <param name="returnType">Return type of the lambda being built.</param>
            <param name="name">Name for the lambda being built.</param>
            <returns>new LambdaBuilder instance</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.ComplexCallHelper(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The complex call helper to create the AST method call node.
            Will add conversions (Expression.Convert()), deals with default parameter values and params arrays.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FlowControlRewriter">
            <summary>
            The purpose of this rewriter is simple: ETs do not allow jumps (break, continue, return, goto)
            that would go through a finally/fault. So we replace them with code that instead stores a flag,
            and then jumps to the end of the finally/fault. At the end of the try-finally, we emit a switch
            that then jumps to the correct label.
            
            A few things that make this more complicated:
            
              1. If a finally contains a jump out, then jumps in the try/catch need to be replaced as well.
                 It's to support cases like this:
                     # returns 234
                     def foo():
                         try: return 123
                         finally: return 234 
                 
                 We need to replace the "return 123" because after it jumps, we'll go to the finally, which
                 might decide to jump again, but once the IL finally exits, it ignores the finally jump and
                 keeps going with the original jump. The moral of the story is: if any jumps in finally are
                 rewritten, try/catch jumps must be also.
                 
             2. To generate better code, we only have one state variable, so if we have to jump out of
                multiple finallys we just keep jumping. It looks sort of like this:
                  foo:
                  try { ... } finally {
                      try { ... } finally {
                        ...
                        if (...) {
                            // was: goto foo;
                            $flow = 1; goto endInnerFinally; 
                        }
                        ...
                        endInnerFinally:
                      }
                      switch ($flow) {
                          case 1: goto endOuterFinally;
                      }
                      ...
                      endOuterFinally:
                  }
                  switch ($flow) {
                    case 1: $flow = 0; goto foo;
                  }
                  ...
            
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ILightExceptionAwareExpression">
            <summary>
            Implemented by expressions which can provide a version which is aware of light exceptions.  
            
            Normally these expressions will simply reduce to a version which throws a real exception.
            When the expression is used inside of a region of code which supports light exceptions
            the light exception re-writer will call ReduceForLightExceptions.  The expression can
            then return a new expression which can return a light exception rather than throwing
            a real .NET exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ILightExceptionBinder">
             <summary>
             Implemented by binders which support light exceptions.  Dynamic objects
             binding against a binder which implements this interface can check 
             SupportsLightThrow to see if the binder currently supports safely 
             returning a light exception.  Light exceptions can be created with
             LightException.Throw.
            
             Binders also need to implement GetlightBinder.  This method
             returns a new call site binder which may return light  exceptions if 
             the binder supports them.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ILightExceptionBinder.GetLightExceptionBinder">
            <summary>
            Gets a binder which will support light exception if one is
            available.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ILightExceptionBinder.SupportsLightThrow">
            <summary>
            Returns true if a callsite binding against this binder can
            return light exceptions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightCheckAndThrowExpression">
            <summary>
            Provides a method call to a method which may return light exceptions. 
            
            The call is to a method which supports light exceptions.  When reducing
            an additional check and throw is added.  When a block code of is re-written
            for light exceptions this instead reduces to not throw a .NET exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightThrowExpression">
            <summary>
            Expression which produces a light exception value.  This should be constructed
            with the expression which creates the exception and this method will then call
            a helper method which wraps the exception in our internal light exception class.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.DebugLambdaInfo">
            <summary>
            Used by compilers to provide additional debug information about LambdaExpression to DebugContext
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.IDebugCompilerSupport">
            <summary>
            Implemented by compilers to allow the traceback engine to get additional information.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.DebugContext">
            <summary>
            Provides services to compilers for instrumenting code with tracebacks.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.CreateInstance">
            <summary>
            Creates a new instance of DebugContext
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.TransformLambda(System.Linq.Expressions.LambdaExpression,Microsoft.Scripting.Debugging.CompilerServices.DebugLambdaInfo)">
            <summary>
            Transforms a LambdaExpression to a debuggable LambdaExpression
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.TransformLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Transforms a LambdaExpression to a debuggable LambdaExpression
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.ResetSourceFile(System.String)">
            <summary>
            Resets a state associated with a source file that's maintained in the DebugContext
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.Threads">
            <summary>
            Threads
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.DebugCallback">
            <summary>
            Hook
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.DebugFrame.ReplaceLiftedLocals(System.Runtime.CompilerServices.IRuntimeVariables)">
            <summary>
            // This method is called from the generator to update the frame with generator's locals
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.DebugFrame.RemapToGenerator(System.Int32)">
            <summary>
            Remaps the frame's state to use the generator for execution.
            </summary>
            <param name="version">Int32.MaxValue to map to latest version</param>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.Thread">
            <summary>
            Thread
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.StackDepth">
            <summary>
            FrameOrder
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.Variables">
            <summary>
            Variables
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.CurrentSequencePointIndex">
            <summary>
            CurrentSequencePointIndex
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebuggableLambdaBuilder">
            <summary>
            DebuggableLambdaBuilder is used to transform a DLR expression tree into a debuggable lambda expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugGenerator`1">
            <summary>
            Used to wrap a lambda that was already a generator prior to transform.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugInfoRewriter">
            <summary>
            Used to rewrite expressions containing DebugInfoExpressions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugSourceSpan">
            <summary>
            Combines source file and span.  Also provides Contains and Intersects functionality.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugRuntimeVariables">
            <summary>
            Implementation of IDebugRuntimeVariables, which wraps IRuntimeVariables + FunctionInfo/DebugMarker
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.IDebugRuntimeVariables">
            <summary>
            IDebugRuntimeVariables is used to wrap IRuntimeVariables and add properties for retrieving
            FunctionInfo and DebugMarker from debuggable labmdas.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DefaultDebugThread">
            <summary>
            Default implementation of BaseDebugThread, which uses DLR's RuntimeVariablesExpression for lifting locals.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DefaultDebugThreadFactory">
            <summary>
            Default implementation of IDebugThreadFactory, which uses DLR's RuntimeVariablesExpression for lifting locals.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.IDebugThreadFactory">
            <summary>
            IDebugThreadFactory is used to abstract how frames and local variables are maintained at run/debug time.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.FunctionInfo.GetTraceLocations">
            <summary>
            GetTraceLocations
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.SequencePoints">
            <summary>
            SequencePoints
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.CustomPayload">
            <summary>
            CustomPayload
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.IDebugCallback.OnDebugEvent(Microsoft.Scripting.Debugging.TraceEventKind,Microsoft.Scripting.Debugging.DebugThread,Microsoft.Scripting.Debugging.FunctionInfo,System.Int32,System.Int32,System.Object)">
            <summary>
            Callback that is fired by the traceback engine
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.LambdaWalker">
            <summary>
            Used to extract locals information from expressions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.ErrorStrings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.ScopedRuntimeVariables">
            <summary>
            Implements IRuntimeVariables in a way that preserves scoping within the lambda.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.TracePipeline">
            <summary>
            TraceSession
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.VariableInfo">
            <summary>
            Used to provide information about locals/parameters at debug time.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.VariableType">
            <summary>
            Type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.IsParameter">
            <summary>
            Parameter
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.TypeMemberCache`1">
            <summary>
            Caches type member lookup.
            </summary>
            <remarks>
            When enumerating members (methods, properties, events) of a type (declared or inherited) Reflection enumerates all
            runtime members of the type and its base types and caches the result.
            When looking for a member of a specific name Reflection still enumerates all and filters out those that don't match the name.
            That's inefficient when looking for members of multiple names one by one.
            Instead we build a map of name to member list and then answer subsequent queries by simply looking up the dictionary.
            </remarks>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightThrowingAttribute">
            <summary>
            Marks a method which may return a light exception.  Such
            methods need to have their return value checked and the exception
            will need to be thrown if the caller is not light exception aware.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightExceptionRewriter">
            <summary>
            Internal re-writer class which creates code which is light exception aware.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LightExceptionRewriter.CheckExpression(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Adds light exception handling to the provided expression which
            is light exception aware.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightExceptionRewriter.LightExceptionRewrittenCode">
            <summary>
            Class used to be avoid overhead of creating expression trees when we're usually 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightExceptions">
            <summary>
            Provides support for light exceptions.  These exceptions are propagated by
            returning an instance of a private wrapper class containing the exception.  Code
            which is aware of light exceptions will branch to apporiate exception handling
            blocks when in a try and otherwise return the value up the stack.  This avoids 
            using the underlying CLR exception mechanism with overhead such as creating stack 
            traces.
            
            When a light exception reaches the boundary of code which is not light exception
            aware the caller must check to see if a light exception is being thrown and if
            so raise a .NET exception.
            
            This class provides methods for re-writing expression trees to support light exceptions,
            methods to create light throw objects, check if an object is a light
            throw object, and turn such an object back into a .NET Exception which can be thrown.
            
            Light exceptions also don't build up stack traces or interoperate with filter blocks
            via 2-pass exception handling.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Rewrite(System.Linq.Expressions.Expression)">
            <summary>
            Rewrites the provided expression to support light exceptions.  
            
            Calls to the returned expression, if not from other light-weight aware calls,
            need to call GetLightException on return to see if an exception was thrown
            and if so throw it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.RewriteLazy(System.Linq.Expressions.Expression)">
            <summary>
            Returns a new expression which will lazily reduce to a light
            expression re-written version of the same expression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.RewriteExternal(System.Linq.Expressions.Expression)">
            <summary>
            Returns a new expression which is re-written for light exceptions
            but will throw an exception if it escapes the expression.  If this
            expression is part of a larger experssion which is later re-written 
            for light exceptions then it will propagate the light exception up.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Exception)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Linq.Expressions.Expression)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression)">
            <summary>
            If the binder supports light exceptions then a light exception throwing expression is returned.
            
            Otherwise a normal throwing expression is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            If the binder supports light exceptions then a light exception throwing expression is returned.
            
            Otherwise a normal throwing expression is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.CheckAndThrow(System.Object)">
            <summary>
            Throws the exception if the value represents a light exception
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.CheckAndThrow(System.Linq.Expressions.Expression)">
            <summary>
            Wraps the expression in a check and rethrow.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.IsLightException(System.Object)">
            <summary>
            Checks to see if the provided value is a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.GetLightException(System.Object)">
            <summary>
            Gets the light exception from an object which may contain a light
            exception.  Returns null if the object is not a light exception.
            
            Used for throwing the exception at non-light exception boundaries.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.SupportsLightThrow(System.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Returns true if the call site binder is a light exception binder and supports
            light throws.  Returns false otherwise.
            </summary>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightExceptions.LightException">
            <summary>
            Sealed wrapper class to indicate something is a light exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceFileInformation">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.FileName">
            <summary>
            The source file name
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.LanguageGuid">
            <summary>
            Returns the language's unique identifier, if any
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.VendorGuid">
            <summary>
            Returns the language vendor's unique identifier, if any
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.FieldBuilderExpression">
            <summary>
            Provides a simple expression which enables embedding FieldBuilder's
            in an AST before the type is complete.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.ICommandDispatcher">
            <summary>
            Used to dispatch a single interactive command. It can be used to control things like which Thread
            the command is executed on, how long the command is allowed to execute, etc
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.Create(System.Reflection.MethodInfo)">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.Create(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.TryGetParameterOrReturnType(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[],System.Int32)">
            <summary>
            Gets the next type or null if no more types are available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.SlowCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Uses reflection to create new instance of the appropriate ReflectedCaller
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.FastCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Fast creation works if we have a known primitive types for the entire
            method siganture.  If we have any non-primitive types then FastCreate
            falls back to SlowCreate which works for all types.
            
            Fast creation is fast because it avoids using reflection (MakeGenericType
            and Activator.CreateInstance) to create the types.  It does this through
            calling a series of generic methods picking up each strong type of the
            signature along the way.  When it runs out of types it news up the 
            appropriate CallInstruction with the strong-types that have been built up.
            
            One relaxation is that for return types which are non-primitive types
            we can fallback to object due to relaxed delegates.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.CallInstruction.ArgumentCount">
            <summary>
            The number of arguments including "this" for instance methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.GotoInstruction">
            <summary>
            This instruction implements a goto expression that can jump out of any expression. 
            It pops values (arguments) from the evaluation stack that the expression tree nodes in between 
            the goto expression and the target label node pushed and not consumed yet. 
            A goto expression can jump into a node that evaluates arguments only if it carries 
            a value and jumps right after the first argument (the carried value will be used as the first argument). 
            Goto can jump into an arbitrary child of a BlockExpression since the block doesnt accumulate values 
            on evaluation stack as its child expressions are being evaluated.
            
            Goto needs to execute any finally blocks on the way to the target label.
            <example>
            { 
                f(1, 2, try { g(3, 4, try { goto L } finally { ... }, 6) } finally { ... }, 7, 8)
                L: ... 
            }
            </example>
            The goto expression here jumps to label L while having 4 items on evaluation stack (1, 2, 3 and 4). 
            The jump needs to execute both finally blocks, the first one on stack level 4 the 
            second one on stack level 2. So, it needs to jump the first finally block, pop 2 items from the stack, 
            run second finally block and pop another 2 items from the stack and set instruction pointer to label L.
            
            Goto also needs to rethrow ThreadAbortException iff it jumps out of a catch handler and 
            the current thread is in "abort requested" state.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.EnterFinallyInstruction">
            <summary>
            The first instruction of finally block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveFinallyInstruction">
            <summary>
            The last instruction of finally block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveExceptionHandlerInstruction">
            <summary>
            The last instruction of a catch exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveFaultInstruction">
            <summary>
            The last instruction of a fault exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.DynamicSplatInstruction">
            <summary>
            Implements dynamic call site with many arguments. Wraps the arguments into <see cref="T:Microsoft.Scripting.Runtime.ArgumentArray"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LabelInfo">
            <summary>
            Contains compiler state corresponding to a LabelTarget
            See also LabelScopeInfo.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LabelScopeInfo.CanJumpInto">
            <summary>
            Returns true if we can jump into this node
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InstructionList.SetDebugCookie(System.Object)">
            <summary>
            Attaches a cookie to the last emitted instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InstructionList.CreateDynamicInstruction(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightDelegateCreator">
            <summary>
            Manages creation of interpreted delegates. These delegates will get
            compiled if they are executed often enough.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.CreateCompiledDelegate(System.Runtime.CompilerServices.StrongBox{System.Object}[])">
            <summary>
            Used by LightLambda to get the compiled delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.Compile(System.Object)">
            <summary>
            Create a compiled delegate for the LightLambda, and saves it so
            future calls to Run will execute the compiled code instead of
            interpreting.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LightDelegateCreator.SameDelegateType">
            <summary>
            true if the compiled delegate has the same type as the lambda;
            false if the type was changed for interpretation.
            </summary>
        </member>
        <member name="E:Microsoft.Scripting.Interpreter.LightLambda.Compile">
            <summary>
            Provides notification that the LightLambda has been compiled.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.Interpreter">
            <summary>
            A simple forth-style stack machine for executing Expression trees
            without the need to compile to IL and then invoke the JIT.  This trades
            off much faster compilation time for a slower execution performance.
            For code that is only run a small number of times this can be a 
            sweet spot.
            
            The core loop in the interpreter is the RunInstructions method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.Interpreter.Run(Microsoft.Scripting.Interpreter.InterpretedFrame)">
            <summary>
            Runs instructions within the given frame.
            </summary>
            <remarks>
            Interpreted stack frames are linked via Parent reference so that each CLR frame of this method corresponds 
            to an interpreted stack frame in the chain. It is therefore possible to combine CLR stack traces with 
            interpreted stack traces by aligning interpreted frames to the frames of this method.
            Each group of subsequent frames of Run method corresponds to a single interpreted frame.
            </remarks>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor">
            <summary>
            Visits a LambdaExpression, replacing the constants with direct accesses
            to their StrongBox fields. This is very similar to what
            ExpressionQuoter does for LambdaCompiler.
            
            Also inserts debug information tracking similar to what the interpreter
            would do.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureVars">
            <summary>
            Local variable mapping.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureArray">
            <summary>
            The variable that holds onto the StrongBox{object}[] closure from
            the interpreter
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._shadowedVars">
            <summary>
            A stack of variables that are defined in nested scopes. We search
            this first when resolving a variable in case a nested scope shadows
            one of our variable instances.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.BindLambda(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,Microsoft.Scripting.Interpreter.LocalVariable})">
            <summary>
            Walks the lambda and produces a higher order function, which can be
            used to bind the lambda to a closure array from the interpreter.
            </summary>
            <param name="lambda">The lambda to bind.</param>
            <param name="closureVariables">Variables which are being accessed defined in the outer scope.</param>
            <returns>A delegate that can be called to produce a delegate bound to the passed in closure array.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.MergedRuntimeVariables">
            <summary>
            Provides a list of variables, supporing read/write of the values
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LocalVariables.CopyLocals">
            <summary>
            Gets a copy of the local variables which are defined in the current scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LocalVariables.ContainsVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Checks to see if the given variable is defined within the current local scope.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LocalVariables.ClosureVariables">
            <summary>
            Gets the variables which are defined in an outer scope and available within the current scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LocalVariables.VariableScope">
            <summary>
            Tracks where a variable is defined and what range of instructions it's used in
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InterpretedFrame.GroupStackFrames(System.Collections.Generic.IEnumerable{System.Diagnostics.StackFrame})">
            <summary>
            A single interpreted frame might be represented by multiple subsequent Interpreter.Run CLR frames.
            This method filters out the duplicate CLR frames.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.BigInteger">
            <summary>
            arbitrary precision integers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Log">
            <summary>
            Calculates the natural logarithm of the BigInteger.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Log10">
            <summary>
            Calculates log base 10 of a BigInteger.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.ToByteArray">
            <summary>
            Return the value of this BigInteger as a little-endian twos-complement
            byte array, using the fewest number of bytes possible. If the value is zero,
            return an array of one byte whose element is 0x00.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.BigInteger.Sign">
            <summary>
            Return the sign of this BigInteger: -1, 0, or 1.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ArgumentArray">
            <summary>
            Wraps all arguments passed to a dynamic site with more arguments than can be accepted by a Func/Action delegate.
            The binder generating a rule for such a site should unwrap the arguments first and then perform a binding to them.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicDelegateCreator">
            <summary>
            Provides support for converting objects to delegates using the DLR binders
            available by the provided language context.
            
            Primarily this supports converting objects implementing IDynamicMetaObjectProvider
            to the appropriate delegate type.  
            
            If the provided object is already a delegate of the appropriate type then the 
            delegate will simply be returned.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicDelegateCreator._dynamicDelegateCache">
            <summary> Table of dynamically generated delegates which are shared based upon method signature. </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicDelegateCreator.GetDelegate(System.Object,System.Type)">
            <summary>
            Creates a delegate with a given signature that could be used to invoke this object from non-dynamic code (w/o code context).
            A stub is created that makes appropriate conversions/boxing and calls the object.
            The stub should be executed within a context of this object's language.
            </summary>
            <returns>The converted delegate.</returns>
            <exception cref="T:Microsoft.Scripting.ArgumentTypeException">The object is either a subclass of Delegate but not the requested type or does not implement IDynamicMetaObjectProvider.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicNull">
            <summary>
            Represents the type of a null value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicNull.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers">
            <summary>
            These are some generally useful helper methods. Currently the only methods are those to
            cached boxed representations of commonly used primitive types so that they can be shared.
            This is useful to most dynamic languages that use object as a universal type.
            
            The methods in RuntimeHelepers are caleld by the generated code. From here the methods may
            dispatch to other parts of the runtime to get bulk of the work done, but the entry points
            should be here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.ShiftParamsArray``1(``0[],System.Int32)">
            <summary>
            Used by prologue code that is injected in lambdas to ensure that delegate signature matches what 
            lambda body expects. Such code typically unwraps subset of the params array manually, 
            but then passes the rest in bulk if lambda body also expects params array.
            
            This calls ArrayUtils.ShiftLeft, but performs additional checks that
            ArrayUtils.ShiftLeft assumes.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.True">
            <summary>
            A singleton boxed boolean true.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.False">
             <summary>
            A singleton boxed boolean false.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.Int32ToObject(System.Int32)">
            <summary>
            Gets a singleton boxed value for the given integer if possible, otherwise boxes the integer.
            </summary>
            <param name="value">The value to box.</param>
            <returns>The boxed value.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.CreateInstance``1">
            <summary>
            Helper method to create an instance.  Work around for Silverlight where Activator.CreateInstance
            is SecuritySafeCritical.
            
            TODO: Why can't we just emit the right thing for default(T)?
            It's always null for reference types and it's well defined for value types
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.InterpretedCallSiteTest(System.Boolean,System.Object)">
            <summary>
            Provides the test to see if an interpreted call site should switch over to being compiled.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorExpression">
            <summary>
            A parameterless generator, that is of type IEnumerable, IEnumerable{T},
            IEnumerator, or IEnumerator{T}. Its body can contain a series of
            YieldExpressions. Each call into MoveNext on the enumerator reenters
            the generator, and executes until it reaches a YieldReturn or YieldBreak
            expression
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Target">
            <summary>
            The label used by YieldBreak and YieldReturn expressions to yield
            from this generator
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Body">
            <summary>
            The body of the generator, which can contain YieldBreak and
            YieldReturn expressions
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.RewriteAssignments">
            <summary>
            Indicates whether the lhs instances are preserved when assignments
            are made to expressions containing yields.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorRewriter">
            <summary>
            When finding a yield return or yield break, this rewriter flattens out
            containing blocks, scopes, and expressions with stack state. All
            scopes encountered have their variables promoted to the generator's
            closure, so they survive yields.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.MakeAssign(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Makes an assignment to this variable. Pushes the assignment as far
            into the right side as possible, to allow jumps into it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.IsConstant(System.Linq.Expressions.Expression)">
            <summary>
            Returns true if the expression remains constant no matter when it is evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.YieldExpression">
            <summary>
            Represents either a YieldBreak or YieldReturn in a GeneratorExpression
            If Value is non-null, it's a YieldReturn; otherwise it's a YieldBreak
            and executing it will stop enumeration of the generator, causing
            MoveNext to return false.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Value">
            <summary>
            The value yieled from this expression, if it is a yield return
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Target">
            <summary>
            The label used to yield from this generator
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.Check(System.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="expression">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.IsConstant(System.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type,System.Int32,Microsoft.Scripting.Generation.EmitArrayHelper)">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SaveSnippets">
            <summary>
            Save snippets to an assembly (see also SnippetsDirectory, SnippetsFileName).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.TypeGen.TypeInitializer">
            <summary>
            Gets the Compiler associated with the Type Initializer (cctor) creating it if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter">
            <summary>
            A tree rewriter which will find dynamic sites which consume dynamic sites and
            turn them into a single combo dynamic site.  The combo dynamic site will then run the
            individual meta binders and produce the resulting code in a single dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter.ComboDynamicSiteExpression">
            <summary>
            A reducible node which we use to generate the combo dynamic sites.  Each time we encounter
            a dynamic site we replace it with a ComboDynamicSiteExpression.  When a child of a dynamic site
            turns out to be a ComboDynamicSiteExpression we will then merge the child with the parent updating
            the binding mapping info.  If any of the inputs cause side effects then we'll stop the combination.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboBinder">
            <summary>
            A binder which can combine multiple binders into a single dynamic site.  The creator
            of this needs to perform the mapping of parameters, constants, and sub-site expressions
            and provide a List of BinderMappingInfo representing this data.  From there the ComboBinder
            just processes the list to create the resulting code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ParameterMappingInfo">
            <summary>
            Provides a mapping for inputs of combo action expressions.  The input can map
            to either an input of the new dynamic site, an input of a previous DynamicExpression,
            or a ConstantExpression which has been pulled out of the dynamic site arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.BinderMappingInfo">
            <summary>
            Contains the mapping information for a single Combo Binder.  This includes the original
            meta-binder and the mapping of parameters, sub-sites, and constants into the binding.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConditionalBuilder">
            <summary>
            Builds up a series of conditionals when the False clause isn't yet known.  We can
            keep appending conditions and if true's.  Each subsequent true branch becomes the
            false branch of the previous condition and body.  Finally a non-conditional terminating
            branch must be added.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddCondition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Adds a new conditional and body.  The first call this becomes the top-level
            conditional, subsequent calls will have it added as false statement of the
            previous conditional.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.FinishCondition(System.Linq.Expressions.Expression)">
            <summary>
            Adds the non-conditional terminating node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.FinishError(System.Linq.Expressions.Expression)">
            <summary>
            Adds the non-conditional terminating node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.GetMetaObject(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets the resulting meta object for the full body.  FinishCondition
            must have been called.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a variable which will be scoped at the level of the final expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NoSideEffectsAttribute">
            <summary>
            Marks a method as not having side effects.  used by the combo binder
            to allow calls to methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.OperatorInfo">
            <summary>
            OperatorInfo provides a mapping from DLR ExpressionType to their associated .NET methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.OperatorInfo.GetOperatorInfo(System.Linq.Expressions.ExpressionType)">
            <summary>
            Given an operator returns the OperatorInfo associated with the operator or null
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Operator">
            <summary>
            The operator the OperatorInfo provides info for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Name">
            <summary>
            The primary method name associated with the method.  This method name is
            usally in the form of op_Operator (e.g. op_Addition).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.AlternateName">
            <summary>
            The secondary method name associated with the method.  This method name is
            usually a standard .NET method name with pascal casing (e.g. Add).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaBuilder">
            <summary>
            The builder for creating the LambdaExpression node.
            
            Since the nodes require that parameters and variables are created
            before hand and then passed to the factories creating LambdaExpression
            this builder keeps track of the different pieces and at the end creates
            the LambdaExpression.
            
            TODO: This has some functionality related to CodeContext that should be
            removed, in favor of languages handling their own local scopes
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Parameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverParameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddParameters(System.Linq.Expressions.ParameterExpression[])">
            <summary>
            adds existing parameter to the lambda.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateHiddenParameter(System.String,System.Type)">
            <summary>
            Creates a hidden parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateParamsArray(System.Type,System.String)">
            <summary>
            Creates a params array argument on the labmda.
            
            The params array argument is added to the signature immediately. Before the lambda is
            created, the builder validates that it is still the last (since the caller can modify
            the order of parameters explicitly by maniuplating the parameter list)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverVariable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Variable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.HiddenVariable(System.Type,System.String)">
            <summary>
            Creates a temporary variable with specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddHiddenVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds the temporary variable to the list of variables maintained
            by the builder. This is useful in cases where the variable is
            created outside of the builder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda(System.Type)">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <param name="lambdaType">Desired type of the lambda. </param>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeGenerator(System.Linq.Expressions.LabelTarget,System.Type)">
            <summary>
            Creates the generator LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.EnsureSignature(System.Type)">
            <summary>
            Fixes up lambda body and parameters to match the signature of the given delegate if needed.
            </summary>
            <param name="delegateType"></param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Validate">
            <summary>
            Validates that the builder has enough information to create the lambda.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Name">
            <summary>
            The name of the lambda.
            Currently anonymous/unnamed lambdas are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ReturnType">
            <summary>
            Return type of the lambda being created.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Locals">
            <summary>
            List of lambda's local variables for direct manipulation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Parameters">
            <summary>
            List of lambda's parameters for direct manipulation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ParamsArray">
            <summary>
            The params array argument, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Body">
            <summary>
            The body of the lambda. This must be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Dictionary">
            <summary>
            The generated lambda should have dictionary of locals
            instead of allocating them directly on the CLR stack.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Visible">
            <summary>
            The scope is visible (default). Invisible if false.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.MultiRuntimeAwareAttribute">
            <summary>
            marks a field, class, or struct as being safe to have statics which can be accessed
            from multiple runtimes.
            
            Static fields which are not read-only or marked with this attribute will be flagged 
            by a test which looks for state being shared between runtimes.  Before applying this
            attribute you should ensure that it is safe to share the state.  This is typically
            state which is lazy initialized or state which is caching values which are identical
            in all runtimes and are immutable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PerfTrack">
            <summary>
            This class is useful for quickly collecting performance counts for expensive
            operations.  Usually this means operations involving either reflection or
            code gen.  Long-term we need to see if this can be plugged better into the
            standard performance counter architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.PerfTrack.Categories.Temporary">
            <summary>
            temporary categories for quick investigation, use a custom key if you
            need to track multiple items, and if you want to keep it then create 
            a new Categories entry and rename all your temporary entries.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CompilerContext">
            <summary>
            Represents the context that is flowed for doing Compiler.  Languages can derive
            from this class to provide additional contextual information.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._sourceUnit">
            <summary>
            Source unit currently being compiled in the CompilerContext
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._errors">
            <summary>
            Current error sink.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._parserSink">
            <summary>
            Sink for parser callbacks (e.g. brace matching, etc.).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._options">
            <summary>
            Compiler specific options.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicLanguageProviderAttribute.LanguageContextType">
            <summary>
            LanguageContext implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicLanguageProviderAttribute.DisplayName">
            <summary>
            Default display name.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicLanguageProviderAttribute.FileExtensions">
            <summary>
            Default file extensions.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicLanguageProviderAttribute.Names">
            <summary>
            Default names for the language.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IConvertibleMetaObject">
            <summary>
            Indicates that a DynamicMetaObject might be convertible to a CLR type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ICustomScriptCodeData">
            <summary>
            Gets custom data to be serialized when saving script codes to disk.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IRestrictedMetaObject">
            <summary>
            Indicates that a MetaObject is already representing a restricted type.  Useful
            when we're already restricted to a known type but this isn't captured in
            the type info (e.g. the type is not sealed).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetLimitType(System.Dynamic.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.LimitType
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetRuntimeType(System.Dynamic.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.RuntimeType
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.SavableScriptCode">
            <summary>
            ScriptCode is an instance of compiled code that is bound to a specific LanguageContext
            but not a specific ScriptScope. The code can be re-executed multiple times in different
            scopes. Hosting API counterpart for this class is <c>CompiledCode</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SavableScriptCode.SaveToAssembly(System.String,Microsoft.Scripting.SavableScriptCode[])">
            <summary>
            This takes an assembly name including extension and saves the provided ScriptCode objects into the assembly.  
            
            The provided script codes can constitute code from multiple languages.  The assemblyName can be either a fully qualified 
            or a relative path.  The DLR will simply save the assembly to the desired location.  The assembly is created by the DLR and 
            if a file already exists than an exception is raised.  
            
            The DLR determines the internal format of the ScriptCode and the DLR can feel free to rev this as appropriate.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SavableScriptCode.LoadFromAssembly(Microsoft.Scripting.Runtime.ScriptDomainManager,System.Reflection.Assembly)">
            <summary>
            This will take an assembly object which the user has loaded and return a new set of ScriptCodes which have 
            been loaded into the provided ScriptDomainManager.  
            
            If the language associated with the ScriptCodes has not already been loaded the DLR will load the 
            LanguageContext into the ScriptDomainManager based upon the saved LanguageContext type.  
            
            If the LanguageContext or the version of the DLR the language was compiled against is unavailable a 
            TypeLoadException will be raised unless policy has been applied by the administrator to redirect bindings.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.Seek(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.SeekRelative(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            A relative displacement with respect to the current position in the token is specified.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.MarkMultiLineTokenEnd">
            <summary>
            Marks token end. Enables to read the current token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.DiscardToken">
            <summary>
            Marks token start. It means the buffer can drop the current token.
            Can be called even if no token has been read yet.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ReadLine">
            <summary>
            Reads till the end of line and returns the character that stopped the reading.
            The returned character is not skipped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ResizeInternal(System.Char[]@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes an array to a speficied new size and copies a portion of the original array into its beginning.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.MethodSignatureInfo">
            <summary>
            Helper class to remove methods w/ identical signatures.  Used for GetDefaultMembers
            which returns members from all types in the hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.OptionsParser.Parse(System.String[],Microsoft.Scripting.Hosting.ScriptRuntimeSetup,Microsoft.Scripting.Hosting.LanguageSetup,Microsoft.Scripting.PlatformAdaptationLayer)">
            <exception cref="T:Microsoft.Scripting.Hosting.Shell.InvalidOptionException">On error.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Math.Complex64">
            <summary>
            Implementation of the complex number data type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.BinderOps">
            <summary>
            Helper methods that calls are generated to from the default DLR binders.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetCombinedParameters(System.Object[],System.Object)">
            <summary>
            Helper function to combine an object array with a sequence of additional parameters that has been splatted for a function call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Cast">
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Cast.Explicit(System.Object,System.Type)">
            <summary>
            Explicitly casts the object to a given type (and returns it as object)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateInfo">
            <summary>
            Used as the value for the ScriptingRuntimeHelpers.GetDelegate method caching system
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DelegateInfo.EmitClrCallStub(Microsoft.Scripting.Generation.ILGen)">
            <summary>
            Generates stub to receive the CLR call and then call the dynamic language code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateSignatureInfo">
            <summary>
            Used as the key for the LanguageContext.GetDelegate method caching system
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ISlice">
            <summary>
            A useful interface for taking slices of numeric arrays, inspired by Python's Slice objects.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Start">
            <summary>
            The starting index of the slice or null if no first index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Stop">
            <summary>
            The ending index of the slice or null if no ending index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Step">
            <summary>
            The length of step to take
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetObject(System.Int64)">
            <summary>
            Given an ID returns the object associated with that ID.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetId(System.Object)">
            <summary>
            Gets a unique ID for an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.Cleanup">
            <summary>
            Goes over the hashtable and removes empty entries 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.Wrapper">
            <summary>
            Weak-ref wrapper caches the weak reference, our hash code, and the object ID.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.WrapperComparer">
            <summary>
            WrapperComparer treats Wrapper as transparent envelope 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider">
            <summary>
            Internal class which binds a LanguageContext, StreamContentProvider, and Encoding together to produce
            a TextContentProvider which reads binary data with the correct language semantics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LocalsDictionary">
            <summary>
            Creates a dictionary of locals in this scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CustomStringDictionary">
            <summary>
            Abstract base class used for optimized thread-safe dictionaries which have a set
            of pre-defined string keys.
            
            Implementers derive from this class and override the GetExtraKeys, TrySetExtraValue, 
            and TryGetExtraValue methods. When looking up a value first the extra keys will be 
            searched using the optimized Try*ExtraValue functions.  If the value isn't found there
            then the value is stored in the underlying .NET dictionary.
            
            This dictionary can store object values in addition to string values.  It also supports
            null keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.GetExtraKeys">
            <summary>
            Gets a list of the extra keys that are cached by the the optimized implementation
            of the module.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.TrySetExtraValue(System.String,System.Object)">
            <summary>
            Try to set the extra value and return true if the specified key was found in the 
            list of extra values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.TryGetExtraValue(System.String,System.Object@)">
            <summary>
            Try to get the extra value and returns true if the specified key was found in the
            list of extra values.  Returns true even if the value is Uninitialized.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary-like object used for caches.
            </summary>
            <param name="maxSize">The maximum number of elements to store.</param>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with 'key', returning true if it's found and
            false if it's not present.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.Add(`0,`1)">
            <summary>
            Adds a new element to the cache, replacing and moving it to the front if the
            element is already present.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.CacheDict`2.Item(`0)">
            <summary>
            Returns the value associated with the given key, or throws KeyNotFoundException
            if the key is not present.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CopyOnWriteList`1">
            <summary>
            List optimized for few writes and multiple reads. It provides thread-safe read and write access. 
            Iteration is not thread-safe by default, but GetCopyForRead allows for iteration 
            without taking a lock.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CopyOnWriteList`1.GetCopyForRead">
            <summary>
            Gets a copy of the contents of the list. The copy will not change even if the original
            CopyOnWriteList object is modified. This method should be used to iterate the list in
            a thread-safe way if no lock is taken. Iterating on the original list is not guaranteed 
            to be thread-safe.
            </summary>
            <returns>The returned copy should not be modified by the caller.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.GetExpressions(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Returns the list of expressions represented by the <see cref="T:System.Dynamic.DynamicMetaObject"/> instances.
            </summary>
            <param name="objects">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances to extract expressions from.</param>
            <returns>The array of expressions.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.ObjectToMetaObject(System.Object,System.Linq.Expressions.Expression)">
            <summary>
            Creates an instance of <see cref="T:System.Dynamic.DynamicMetaObject"/> for a runtime value and the expression that represents it during the binding process.
            </summary>
            <param name="argValue">The runtime value to be represented by the <see cref="T:System.Dynamic.DynamicMetaObject"/>.</param>
            <param name="parameterExpression">An expression to represent this <see cref="T:System.Dynamic.DynamicMetaObject"/> during the binding process.</param>
            <returns>The new instance of <see cref="T:System.Dynamic.DynamicMetaObject"/>.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.LightBind``1(System.Dynamic.DynamicMetaObjectBinder,System.Object[],System.Int32)">
            <summary>
            Produces an interpreted binding using the given binder which falls over to a compiled
            binding after hitCount tries.
            
            This method should be called whenever an interpreted binding is required.  Sometimes it will
            return a compiled binding if a previous binding was produced and it's hit count was exhausted.
            In this case the binder will not be called back for a new binding - the previous one will
            be used.
            </summary>
            <typeparam name="T">The delegate type being used for the call site</typeparam>
            <param name="binder">The binder used for the call site</param>
            <param name="compilationThreshold">The number of calls before the binder should switch to a compiled mode.</param>
            <param name="args">The arguments that are passed for the binding (as received in a BindDelegate call)</param>
            <returns>A delegate which represents the interpreted binding.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DynamicUtils.GenericInterpretedBinder`1.InterpretedRuleHitCheckExpression">
            <summary>
            Expression which reduces to the normal test but under the interpreter adds a count down
            check which enables compiling when the count down is reached.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CachedBindingInfo">
            <summary>
            Base class for storing information about the binding that a specific rule is applicable for.
            
            We have a derived generic class but this class enables us to refer to it w/o having the
            generic type information around.
            
            This class tracks both the count down to when we should compile.  When we compile we
            take the Expression[T] that was used before and compile it.  While this is happening
            we continue to allow the interpreted code to run.  When the compilation is complete we
            store a thread static which tells us what binding failed and the current rule is no
            longer functional.  Finally the language binder will call us again and we'll retrieve
            and return the compiled overload.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.HybridReferenceDictionary`2">
            <summary>
            A hybrid dictionary which compares based upon object identity.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorDivideUnchecked(System.Int32,System.Int32)">
            <summary>
            Calculates the quotient of two 32-bit signed integers rounded towards negative infinity.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The quotient of the specified numbers rounded towards negative infinity, or <code>(int)Floor((double)x/(double)y)</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
            <remarks>The caller must check for overflow (x = Int32.MinValue, y = -1)</remarks>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorDivideUnchecked(System.Int64,System.Int64)">
            <summary>
            Calculates the quotient of two 32-bit signed integers rounded towards negative infinity.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The quotient of the specified numbers rounded towards negative infinity, or <code>(int)Floor((double)x/(double)y)</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
            <remarks>The caller must check for overflow (x = Int64.MinValue, y = -1)</remarks>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorRemainder(System.Int32,System.Int32)">
            <summary>
            Calculates the remainder of floor division of two 32-bit signed integers.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The remainder of of floor division of the specified numbers, or <code>x - (int)Floor((double)x/(double)y) * y</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorRemainder(System.Int64,System.Int64)">
            <summary>
            Calculates the remainder of floor division of two 32-bit signed integers.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The remainder of of floor division of the specified numbers, or <code>x - (int)Floor((double)x/(double)y) * y</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double)">
            <summary>
            Behaves like Math.Round(value, MidpointRounding.AwayFromZero)
            Needed because CoreCLR doesn't support this particular overload of Math.Round
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double,System.Int32)">
            <summary>
            Behaves like Math.Round(value, precision, MidpointRounding.AwayFromZero)
            However, it works correctly on negative precisions and cases where precision is
            outside of the [-15, 15] range.
            
            (This function is also needed because CoreCLR lacks this overload.)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.EvalPolynomial(System.Double,System.Double[])">
            <summary>
            Evaluates a polynomial in v0 where the coefficients are ordered in increasing degree
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.EvalPolynomial(System.Double,System.Double[],System.Boolean)">
            <summary>
            Evaluates a polynomial in v0 where the coefficients are ordered in increasing degree
            if reverse is false, and increasing degree if reverse is true.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.SinPi(System.Double)">
            <summary>
            A numerically precise version of sin(v0 * pi)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.AbsSinPi(System.Double)">
            <summary>
            A numerically precise version of |sin(v0 * pi)|
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.GammaRationalFunc(System.Double)">
            <summary>
            Take the quotient of the 2 polynomials forming the Lanczos approximation
            with N=13 and G=13.144565
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.PositiveGamma(System.Double)">
            <summary>
            Computes the Gamma function on positive values, using the Lanczos approximation.
            Lanczos parameters are N=13 and G=13.144565.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.PositiveLGamma(System.Double)">
            <summary>
            Computes the Log-Gamma function on positive values, using the Lanczos approximation.
            Lanczos parameters are N=13 and G=13.144565.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2">
            <summary>
            Thread safe dictionary that allows lazy-creation where readers will block for
            the creation of the lazily created value.  Call GetOrCreateValue w/ a key
            and a callback function.  If the value exists it is returned, if not the create
            callback is called (w/o any locks held).  The create call back will only be called
            once for each key.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2.PublishInfo`1">
            <summary>
            Helper class which stores the published value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1">
            <summary>
            Provides fast strongly typed thread local storage.  This is significantly faster than
            Thread.GetData/SetData.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.#ctor(System.Boolean)">
            <summary>
            True if the caller will guarantee that all cleanup happens as the thread
            unwinds.
            
            This is typically used in a case where the thread local is surrounded by
            a try/finally block.  The try block pushes some state, the finally block
            restores the previous state.  Therefore when the thread exits the thread
            local is back to it's original state.  This allows the ThreadLocal object
            to not check the current owning thread on retrieval.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetOrCreate(System.Func{`0})">
            <summary>
            Gets the current value if its not == null or calls the provided function
            to create a new value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.Update(System.Func{`0,`0})">
            <summary>
            Calls the provided update function with the current value and
            replaces the current value with the result of the function.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.Update(`0)">
            <summary>
            Replaces the current value with a new one and returns the old value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetStorageInfo">
            <summary>
            Gets the StorageInfo for the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.RetryOrCreateStorageInfo(Microsoft.Scripting.Utils.ThreadLocal{`0}.StorageInfo[])">
            <summary>
            Called when the fast path storage lookup fails. if we encountered the Empty storage 
            during the initial fast check then spin until we hit non-empty storage and try the fast 
            path again.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.CreateStorageInfo">
            <summary>
            Creates the StorageInfo for the thread when one isn't already present.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value for the current thread.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1.StorageInfo">
            <summary>
            Helper class for storing the value.  We need to track if a ManagedThreadId
            has been re-used so we also store the thread which owns the value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ValueArray`1">
            <summary>
            Represents an array that has value equality.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakCollection`1">
            <summary>
            Simple class for tracking a list of items and enumerating over them.
            The items are stored in weak references; if the objects are collected,
            they will not be seen when enumerating.
            </summary>
            <typeparam name="T">The type of the collection element.</typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakDictionary`2">
            <summary>
            Similar to Dictionary[TKey,TValue], but it also ensures that the keys will not be kept alive
            if the only reference is from this collection. The value will be kept alive as long as the key
            is alive.
            
            This currently has a limitation that the caller is responsible for ensuring that an object used as 
            a key is not also used as a value in *any* instance of a WeakHash. Otherwise, it will result in the
            object being kept alive forever. This effectively means that the owner of the WeakHash should be the
            only one who has access to the object used as a value.
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.WeakDictionary`2.CheckCleanup">
            <summary>
            Check if any of the keys have gotten collected
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DebugOptions">
            <summary>
            This class holds onto internal debugging options used in this assembly. 
            These options can be set via environment variables DLR_{option-name}.
            Boolean options map "true" to true and other values to false.
            
            These options are for internal debugging only, and should not be
            exposed through any public APIs.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.SetNestedValue(System.Int32,System.Int32,System.Object)">
            <summary>
            Sets the value at the given index for a tuple of the given size.  This set supports
            walking through nested tuples to get the correct final index.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetNestedValue(System.Int32,System.Int32)">
            <summary>
            Gets the value at the given index for a tuple of the given size.  This get
            supports walking through nested tuples to get the correct final index.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetTupleType(System.Int32)">
            <summary>
            Gets the unbound generic Tuple type which has at lease size slots or null if a large enough tuple is not available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.MakeTupleType(System.Type[])">
            <summary>
            Creates a generic tuple with the specified types.  
            
            If the number of slots fits within the maximum tuple size then we simply 
            create a single tuple.  If it's greater then we create nested tuples 
            (e.g. a Tuple`2 which contains a Tuple`128 and a Tuple`8 if we had a size of 136).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetSize(System.Type)">
            <summary>
            Gets the number of usable slots in the provided Tuple type including slots available in nested tuples.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.MakeTuple(System.Type,System.Object[])">
            <summary>
            Creates a new instance of tupleType with the specified args.  If the tuple is a nested
            tuple the values are added in their nested forms.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetTupleValues(Microsoft.Scripting.MutableTuple)">
            <summary>
            Gets the values from a tuple including unpacking nested values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetAccessPath(System.Type,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetAccessProperties(System.Type,System.Int32,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.Create(System.Linq.Expressions.Expression[])">
            <summary>
            Provides an expression for creating a tuple with the specified values.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Argument">
            <summary>
            TODO: Alternatively, it should be sufficient to remember indices for this, list, dict and block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ArgumentType">
            <summary>
            Convention for an individual argument at a callsite.
            
            Multiple different callsites can match against a single declaration. 
            Some argument kinds can be "unrolled" into multiple arguments, such as list and dictionary. 
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Simple">
            <summary>
            Simple unnamed positional argument.
            In Python: foo(1,2,3) are all simple arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Named">
            <summary>
            Argument with associated name at the callsite
            In Python: foo(a=1)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.List">
            <summary>
            Argument containing a list of arguments. 
            In Python: foo(*(1,2*2,3))  would match 'def foo(a,b,c)' with 3 declared arguments such that (a,b,c)=(1,4,3).
                 it could also match 'def foo(*l)' with 1 declared argument such that l=(1,4,3)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Dictionary">
            <summary>
            Argument containing a dictionary of named arguments.
            In Python: foo(**{'a':1, 'b':2})
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker">
            <summary>
            Represents a logical member of a type.  The member could either be real concrete member on a type or
            an extension member.
            
            This seperates the "physical" members that .NET knows exist on types from the members that
            logically exist on a type.  It also provides other abstractions above the level of .NET reflection
            such as MemberGroups and NamespaceTracker's.
            
            It also provides a wrapper around the reflection APIs which cannot be extended from partial trust.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Gets the expression that creates the value.  
            
            Returns null if it's an error to get the value.  The caller can then call GetErrorForGet to get 
            the correct error Expression (or null if they should provide a default).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.Call(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets an expression that performs a call on the object using the specified arguments.
            
            Returns null if it's an error to perform the specific operation.  The caller can then call 
            GetErrorsForDoCall to get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetError(Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Returns the error associated with getting the value.  
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundError(Microsoft.Scripting.Actions.ActionBinder,System.Dynamic.DynamicMetaObject,System.Type)">
            <summary>
            Returns the error associated with accessing this member via a bound instance.
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for getting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.BindToInstance(System.Dynamic.DynamicMetaObject)">
            <summary>
            Binds the member tracker to the specified instance rturning a new member tracker if binding 
            is possible.  If binding is not possible the existing member tracker will be returned.  For example
            binding to a static field results in returning the original MemberTracker.  Binding to an instance
            field results in a new BoundMemberTracker which will get GetBoundValue/SetBoundValue to pass the
            instance through.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.MemberType">
            <summary>
            The type of member tracker.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.DeclaringType">
            <summary>
            The logical declaring type of the member.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.Name">
            <summary>
            The name of the member.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker.MemberKey">
            <summary>
            We ensure we only produce one MemberTracker for each member which logically lives on the declaring type.  So 
            for example if you get a member from a derived class which is declared on the base class it should be the same 
            as getting the member from the base class.  Thats easy enough until you get into extension members  here there
            might be one extension member which is being applied to multiple types.  Therefore we need to take into account the 
            extension type when ensuring that we only have 1 MemberTracker ever created.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSignature">
            <summary>
            Richly represents the signature of a callsite.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._infos">
            <summary>
            Array of additional meta information about the arguments, such as named arguments.
            Null for a simple signature that's just an expression list. eg: foo(a*b,c,d)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._argumentCount">
            <summary>
            Number of arguments in the signature.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.HasKeywordArgument">
            <summary>
            True if the OldCallAction includes an ArgumentInfo of ArgumentKind.Dictionary or ArgumentKind.Named.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.GetProvidedPositionalArgumentCount">
            <summary>
            Gets the number of positional arguments the user provided at the call site.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSignature.IsSimple">
            <summary>
            All arguments are unnamed and matched by position. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CustomTracker">
            <summary>
            A custom member tracker which enables languages to plug in arbitrary
            members into the lookup process.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorInfo">
            <summary>
            Encapsulates information about the result that should be produced when 
            a OldDynamicAction cannot be performed.  The ErrorInfo can hold one of:
                an expression which creates an Exception to be thrown 
                an expression which produces a value which should be returned 
                    directly to the user and represents an error has occured (for
                    example undefined in JavaScript)
                an expression which produces a value which should be returned
                    directly to the user but does not actually represent an error.
            
            ErrorInfo's are produced by an ActionBinder in response to a failed
            binding.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.#ctor(System.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ErrorInfoKind)">
            <summary>
            Private constructor - consumers must use static From* factories
            to create ErrorInfo objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromException(System.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents an exception that should
            be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValue(System.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents a value which should be
            returned to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValueNoError(System.Linq.Expressions.Expression)">
            <summary>
            Crates a new ErrorInfo which represents a value which should be returned
            to the user but does not represent an error.
            </summary>
            <param name="resultValue"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Exception">
            <summary>
            The ErrorInfo expression produces an exception
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Error">
            <summary>
            The ErrorInfo expression produces a value which represents the error (e.g. undefined)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Success">
            <summary>
            The ErrorInfo expression produces a value which is not an error
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.EventTracker.IsStatic">
            <summary>
            Doesn't need to check PrivateBinding setting: no method that is part of the event is public the entire event is private. 
            If the code has already a reference to the event tracker instance for a private event its "static-ness" is not influenced 
            by private-binding setting.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.EventTracker.HandlerList">
            <summary>
            Holds on a list of delegates hooked to the event. 
            We need the list because we cannot enumerate the delegates hooked to CLR event and we need to do so in 
            handler removal (we need to do custom delegate comparison there). If BCL enables the enumeration we could remove this.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.EventTracker.NormalHandlerList._handlers">
            <summary>
            Storage for the handlers - a key value pair of the callable object and the delegate handler.
            
            The delegate handler is closed over the callable object.  Therefore as long as the object is alive the
            delegate will stay alive and so will the callable object.  That means it's fine to have a weak reference
            to both of these objects.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExtensionMethodTracker">
            <summary>
            Represents extension method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ExtensionMethodTracker._declaringType">
            <summary>
            The declaring type of the extension (the type this extension method extends)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExtensionMethodTracker.DeclaringType">
            <summary>
            The declaring type of the extension method. Since this is an extension method,
            the declaring type is in fact the type this extension method extends,
            not Method.DeclaringType
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.PropertyTracker">
            <summary>
            Represents a logical Property as a member of a Type.  This Property can either be a real 
            concrete Property on a type (implemented with a ReflectedPropertyTracker) or an extension
            property (implemented with an ExtensionPropertyTracker).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberGroup">
            <summary>
            MemberGroups are a collection of MemberTrackers which are commonly produced
            on-demand to talk about the available members.  They can consist of a mix of
            different member types or multiple membes of the same type.
            
            The most common source of MemberGroups is from ActionBinder.GetMember.  From here
            the DLR will perform binding to the MemberTrackers frequently producing the value
            resulted from the user.  If the result of the action produces a member it's self
            the ActionBinder can provide the value exposed to the user via ReturnMemberTracker.
            
            ActionBinder provides default functionality for both getting members from a type
            as well as exposing the members to the user.  Getting members from the type maps
            closely to reflection and exposing them to the user exposes the MemberTrackers
            directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MethodGroup">
            <summary>
            MethodGroup's represent a unique collection of method's.  Typically this
            unique set is all the methods which are overloaded by the same name including
            methods with different arity.  These methods represent a single logically
            overloaded element of a .NET type.
            
            The base DLR binders will produce MethodGroup's when provided with a MemberGroup
            which contains only methods.  The MethodGroup's will be unique instances per
            each unique group of methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MethodGroup.MakeGenericMethod(System.Type[])">
            <summary>
            Returns a BuiltinFunction bound to the provided type arguments.  Returns null if the binding
            cannot be performed.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker">
            <summary>
            NamespaceTracker represent a CLS namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IMembersList">
            <summary>
            Provides a list of all the members of an instance.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.LoadAllTypes">
            <summary>
            Loads all the types from all assemblies that contribute to the current namespace (but not child namespaces)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.GetOrMakePackageHierarchy(System.Reflection.Assembly,System.String)">
            <summary>
            Populates the tree with nodes for each part of the namespace
            </summary>
            <param name="assem"></param>
            <param name="fullNamespace">Full namespace name. It can be null (for top-level types)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.CheckForUnlistedType(System.String)">
            <summary>
            As a fallback, so if the type does exist in any assembly. This would happen if a new type was added
            that was not in the hardcoded list of types. 
            This code is not accurate because:
            1. We dont deal with generic types (TypeCollision). 
            2. Previous calls to GetCustomMemberNames (eg. "from foo import *" in Python) would not have included this type.
            3. This does not deal with new namespaces added to the assembly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker.TypeNames">
            <summary>
            This stores all the public non-nested type names in a single namespace and from a single assembly.
            This allows inspection of the namespace without eagerly loading all the types. Eagerly loading
            types slows down startup, increases working set, and is semantically incorrect as it can trigger
            TypeLoadExceptions sooner than required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeTracker.op_Explicit(Microsoft.Scripting.Actions.TypeTracker)~System.Type">
            <summary>
            Enables implicit Type to TypeTracker conversions accross dynamic languages.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TopNamespaceTracker">
            <summary>
            Represents the top reflected package which contains extra information such as
            all the assemblies loaded and the built-in modules.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.TryGetPackage(System.String)">
            <summary>
            returns the package associated with the specified namespace and
            updates the associated module to mark the package as imported.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.LoadAssembly(System.Reflection.Assembly)">
            <summary>
            Ensures that the assembly is loaded
            </summary>
            <param name="assem"></param>
            <returns>true if the assembly was loaded for the first time. 
            false if the assembly had already been loaded before</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.PublishComTypes(System.Reflection.Assembly)">
            <summary>
            When an (interop) assembly is loaded, we scan it to discover the GUIDs of COM interfaces so that we can
            associate the type definition with COM objects with that GUID.
            Since scanning all loaded assemblies can be expensive, in the future, we might consider a more explicit 
            user binder to trigger scanning of COM types.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Constructor">
            <summary> Specifies that the member is a constructor, representing a ConstructorTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Event">
            <summary> Specifies that the member is an event, representing a EventTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Field">
            <summary> Specifies that the member is a field, representing a FieldTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Method">
            <summary> Specifies that the member is a method, representing a MethodTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Property">
            <summary> Specifies that the member is a property, representing a PropertyTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Type">
            <summary> Specifies that the member is a property, representing a TypeTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Namespace">
            <summary> Specifies that the member is a namespace, representing a NamespaceTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.MethodGroup">
            <summary> Specifies that the member is a group of method overloads, representing a MethodGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.TypeGroup">
            <summary> Specifies that the member is a group of types that very by arity, representing a TypeGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Custom">
            <summary> Specifies that the member is a custom meber, represetning a CustomTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Bound">
            <summary> Specifies that the member is a bound to an instance, representing a BoundMemberTracker</summary>        
        </member>
        <member name="T:Microsoft.Scripting.Actions.TypeGroup">
            <summary>
            A TypeCollision is used when we have a collision between
            two types with the same name.  Currently this is only possible w/ generic
            methods that should logically have arity as a portion of their name. For eg:
                 System.EventHandler and System.EventHandler[T]
                 System.Nullable and System.Nullable[T]
                 System.IComparable and System.IComparable[T]
            
            The TypeCollision provides an indexer but also is a real type.  When used
            as a real type it is the non-generic form of the type.
            
            The indexer allows the user to disambiguate between the generic and
            non-generic versions.  Therefore users must always provide additional
            information to get the generic version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.UpdateTypeEntity(Microsoft.Scripting.Actions.TypeTracker,Microsoft.Scripting.Actions.TypeTracker)">
            <param name="existingTypeEntity">The merged list so far. Could be null</param>
            <param name="newType">The new type(s) to add to the merged list</param>
            <returns>The merged list.  Could be a TypeTracker or TypeGroup</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetGenericArity(System.Type)">
            <summary> Gets the arity of generic parameters</summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetNonGenericType">
            <exception cref="T:System.TypeLoadException">No non-generic type is represented by this group.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.DeclaringType">
            <summary>
            This returns the DeclaringType of all the types in the TypeGroup
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Name">
            <summary>
            This returns the base name of the TypeGroup (the name shared by all types minus arity)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Type">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.IsPublic">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsConstructor(System.Reflection.MethodBase)">
            <summary>
            True if the MethodBase is method which is going to construct an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetType(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTypes(System.Object[])">
            <summary>
            Simply returns a Type[] from calling GetType on each element of args.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TypesEqual(System.Collections.IList,System.Int32,System.Type[])">
            <summary>
            EMITTED
            Used by default method binder to check types of splatted arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TryGetCallableMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Returns the original method if the method if a public version cannot be found.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.FilterNonVisibleMembers(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Non-public types can have public members that we find when calling type.GetMember(...).  This
            filters out the non-visible members by attempting to resolve them to the correct visible type.
            
            If no correct visible type can be found then the member is not visible and we won't call it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.MemberEquals(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
            <summary>
            Sees if two MemberInfos point to the same underlying construct in IL.  This
            ignores the ReflectedType property which exists on MemberInfos which
            causes direct comparisons to be false even if they are the same member.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile(System.Linq.Expressions.LambdaExpression,System.Int32)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <param name="compilationThreshold">The number of iterations before the interpreter starts compiling</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <typeparam name="T">The lambda's delegate type.</typeparam>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile``1(System.Linq.Expressions.Expression{``0},System.Int32)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <param name="compilationThreshold">The number of iterations before the interpreter starts compiling</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder,System.Boolean)">
            <summary>
            Compiles the lambda into a method definition.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder"/> which will be used to hold the lambda's IL.</param>
            <param name="emitDebugSymbols">A parameter that indicates if debugging information should be emitted to a PDB symbol store.</param>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Compile``1(System.Linq.Expressions.Expression{``0},System.Boolean)">
            <summary>
            Compiles the LambdaExpression.
            
            If the lambda is compiled with emitDebugSymbols, it will be
            generated into a TypeBuilder. Otherwise, this method is the same as
            calling LambdaExpression.Compile()
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="emitDebugSymbols">true to generate a debuggable method, false otherwise</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.CompileToMethod``1(System.Linq.Expressions.Expression{``0},System.Runtime.CompilerServices.DebugInfoGenerator,System.Boolean)">
            <summary>
            Compiles the LambdaExpression, emitting it into a new type, and
            optionally making it debuggable.
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
            <param name="emitDebugSymbols">True if debug symbols (PDBs) are emitted by the <paramref name="debugInfoGenerator"/>.</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Reduce(System.Linq.Expressions.DynamicExpression)">
            <summary>
            Reduces the provided DynamicExpression into site.Target(site, *args).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.CompilerHelpers.DebuggableCodeRewriter">
            <summary>
            Removes all live objects and places them in static fields of a type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IExpressionSerializable">
            <summary>
            Enables an object to be serializable to an Expression tree.  The expression tree can then
            be emitted into an assembly enabling the de-serialization of the object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ToDiskRewriter">
            <summary>
            Serializes constants and dynamic sites so the code can be saved to disk
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Normal">
            <summary>
            The MethodBinder will perform normal method binding.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.BinaryOperator">
            <summary>
            The MethodBinder will return the languages definition of NotImplemented if the arguments are
            incompatible with the signature.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Constructor">
            <summary>
            The MethodBinder will set properties/fields for unused keyword arguments on the instance 
            that gets returned from the method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrMainCallTarget">
            <summary>
            The delegate representing the DLR Main function
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrCachedCodeAttribute">
            <summary>
            An attribute that is applied to saved ScriptCode's to be used to re-create the ScriptCode
            from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CachedOptimizedCodeAttribute.Names">
            <summary>
            Gets names stored in optimized scope. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DocumentationAttribute">
            <summary>
            Provides a mechanism for providing documentation stored in an assembly as metadata.  
            
            Applying this attribute will enable documentation to be provided to the user at run-time
            even if XML Documentation files are unavailable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.UpdateForRethrow(System.Exception)">
            <summary>
            Updates an exception before it's getting re-thrown so
            we can present a reasonable stack trace to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetExceptionStackTraces(System.Exception)">
            <summary>
            Returns all the stack traces associates with an exception
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExtensionTypeAttribute">
            <summary>
            Marks a class in the assembly as being an extension type for another type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Marks a type in the assembly as being an extension type for another type.
            </summary>
            <param name="extends">The type which is being extended</param>
            <param name="extensionType">The type which provides the extension members.</param>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.ExtensionType">
            <summary>
            The type which contains extension members which are added to the type being extended.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.Extends">
            <summary>
            The type which is being extended by the extension type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CheckedDictionaryEnumerator">
            <summary>
            Not all .NET enumerators throw exceptions if accessed in an invalid state. This type
            can be used to throw exceptions from enumerators implemented in IronPython.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeEventArgs">
            <summary>
            Event args for when a ScriptScope has had its contents changed.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(System.String,Microsoft.Scripting.Runtime.ModuleChangeType)">
            <summary>
            Creates a new ModuleChangeEventArgs object with the specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(System.String,Microsoft.Scripting.Runtime.ModuleChangeType,System.Object)">
            <summary>
            Creates a nwe ModuleChangeEventArgs with the specified name, type, and changed value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Name">
            <summary>
            Gets the name of the symbol that has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.ChangeType">
            <summary>
            Gets the way in which the symbol has changed: Set or Delete.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Value">
            <summary>
            The the symbol has been set provides the new value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeType">
            <summary>
            The way in which a module has changed : Set or Delete
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Set">
            <summary>
            A new value has been set in the module (or a previous value has changed).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Delete">
            <summary>
            A value has been removed from the module.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NullTextContentProvider">
            <summary>
            A NullTextContentProvider to be provided when we have a pre-compiled ScriptCode which doesn't
            have source code associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperationFailed">
            <summary>
            Singleton instance returned from an operator method when the operator method cannot provide a value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperatorSlotAttribute">
            <summary>
            Represents an ops-extension method which is added as an operator.
            
            The name must be a well-formed name such as "Add" that matches the CLS
            naming conventions for adding overloads associated with op_* methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PropertyMethodAttribute">
            <summary>
            Represents an ops-extension method which is used to implement a property.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache">
            <summary>
            Provides a cache of reflection members.  Only one set of values is ever handed out per a 
            specific request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache.MethodBaseCache">
            <summary>
            TODO: Make me private again
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.StaticExtensionMethodAttribute">
            <summary>
            Indicates an extension method should be added as a static method, not a instance method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts a generic ICollection of T into an array of T.  
            
            If the collection is already an  array of T the original collection is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Converts a generic ICollection of T into an array of R using a given conversion.  
            
            If the collection is already an array of R the original collection is returned.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.EnumerableWrapper">
            <summary>
            Allows wrapping of proxy types (like COM RCWs) to expose their IEnumerable functionality
            which is supported after casting to IEnumerable, even though Reflection will not indicate 
            IEnumerable as a supported interface
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex(System.Int32,System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex(System.Int32,System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.Int32,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Requires the enumerable collection and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DictionaryUnionEnumerator">
            <summary>
            Presents a flat enumerable view of multiple dictionaries
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation_ContainsGenericParameters(System.Object,System.Object)">
            <summary>
            A string like  "Cannot access member {1} declared on type {0} because the type contains generic parameters."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MissingType(System.Object)">
            <summary>
            A string like  "Type '{0}' is missing or cannot be loaded."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAccessFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be read through a type, not an instance"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAssignmentFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be assigned to through a type, not an instance"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnknownMemberType(System.Object)">
            <summary>
            A string like  "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NonGenericWithGenericGroup(System.Object)">
            <summary>
            A string like  "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            A string like  "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoCallableMethods(System.Object,System.Object)">
            <summary>
            A string like  "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExtensionMustBePublic(System.Object)">
            <summary>
            A string like  "Extension type {0} must be public."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            A string like  "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.FieldReadonly(System.Object)">
            <summary>
            A string like  "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.PropertyReadonly(System.Object)">
            <summary>
            A string like  "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExpectedBoundEvent(System.Object)">
            <summary>
            A string like  "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedType(System.Object,System.Object)">
            <summary>
            A string like  "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MemberWriteOnly(System.Object)">
            <summary>
            A string like  "can only write to member {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidStreamType(System.Object)">
            <summary>
            A string like  "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddCasing(System.Object)">
            <summary>
            A string like  "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddIdentifier(System.Object)">
            <summary>
            A string like  "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCtorImplementation(System.Object,System.Object)">
            <summary>
            A string like  "Type '{0}' doesn't provide a suitable public constructor or its implementation is faulty: {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            A string like  "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoImplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoExplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NameNotDefined(System.Object)">
            <summary>
            A string like  "name '{0}' not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.IllegalNew_GenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustBeExceptionInstance">
            <summary>
            A string like  "must by an Exception instance"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfTestMustBeBool">
            <summary>
            A string like  "Type of test must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfExpressionMustBeBool">
            <summary>
            A string like  "Type of the expression must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EmptyStringIsInvalidPath">
            <summary>
            A string like  "Empty string is not a valid path."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidDelegate">
            <summary>
            A string like  "Invalid delegate type (Invoke method not found)."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ExpectedStaticProperty">
            <summary>
            A string like  "expected only static property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.PropertyDoesNotExist">
            <summary>
            A string like  "Property doesn't exist on the provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FieldDoesNotExist">
            <summary>
            A string like  "Field doesn't exist on provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustHaveCodeOrTarget">
            <summary>
            A string like  "Either code or target must be specified."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoInstanceForCall">
            <summary>
            A string like  "no instance for call."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTest">
            <summary>
            A string like  "Missing Test."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTarget">
            <summary>
            A string like  "Missing Target."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FinallyAlreadyDefined">
            <summary>
            A string like  "Finally already defined."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotHaveFaultAndFinally">
            <summary>
            A string like  "Can not have fault and finally."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FaultAlreadyDefined">
            <summary>
            A string like  "Fault already defined."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GlobalsMustBeUnique">
            <summary>
            A string like  "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GenNonSerializableBinder">
            <summary>
            A string like  "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidPath">
            <summary>
            A string like  "pecified path is invalid."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.DictionaryNotHashable">
            <summary>
            A string like  "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.LanguageRegistered">
            <summary>
            A string like  "language already registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodOrOperatorNotImplemented">
            <summary>
            A string like  "The method or operation is not implemented."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoException">
            <summary>
            A string like  "No exception."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.AlreadyInitialized">
            <summary>
            A string like  "Already initialized."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustReturnScopeExtension">
            <summary>
            A string like  "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidParamNumForService">
            <summary>
            A string like  "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotChangeNonCachingValue">
            <summary>
            A string like  "Cannot change non-caching value."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoCodeToCompile">
            <summary>
            A string like  "No code to compile."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationNotStarted">
            <summary>
            A string like  "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationFinished">
            <summary>
            A string like  "Enumeration already finished."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoDefaultValue">
            <summary>
            A string like  "No default value for a given type."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.UnknownLanguageProviderType">
            <summary>
            A string like  "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantReadProperty">
            <summary>
            A string like  "can't read from property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantWriteProperty">
            <summary>
            A string like  "can't write to property"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustHaveCodeOrTarget">
            <summary>
            ArgumentException with message like "Either code or target must be specified."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FirstArgumentMustBeCallSite">
            <summary>
            InvalidOperationException with message like "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoInstanceForCall">
            <summary>
            InvalidOperationException with message like "no instance for call."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTest">
            <summary>
            InvalidOperationException with message like "Missing Test."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTarget">
            <summary>
            InvalidOperationException with message like "Missing Target."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NonGenericWithGenericGroup(System.Object)">
            <summary>
            TypeLoadException with message like "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FinallyAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Finally already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotHaveFaultAndFinally">
            <summary>
            InvalidOperationException with message like "Can not have fault and finally."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FaultAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Fault already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCallableMethods(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GlobalsMustBeUnique">
            <summary>
            ArgumentException with message like "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GenNonSerializableBinder">
            <summary>
            ArgumentException with message like "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidPath">
            <summary>
            ArgumentException with message like "pecified path is invalid."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DictionaryNotHashable">
            <summary>
            ArgumentTypeException with message like "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.LanguageRegistered">
            <summary>
            InvalidOperationException with message like "language already registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MethodOrOperatorNotImplemented">
            <summary>
            NotImplementedException with message like "The method or operation is not implemented."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoException">
            <summary>
            InvalidOperationException with message like "No exception."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExtensionMustBePublic(System.Object)">
            <summary>
            ArgumentException with message like "Extension type {0} must be public."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.AlreadyInitialized">
            <summary>
            InvalidOperationException with message like "Already initialized."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustReturnScopeExtension">
            <summary>
            InvalidImplementationException with message like "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidParamNumForService">
            <summary>
            ArgumentException with message like "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotChangeNonCachingValue">
            <summary>
            ArgumentException with message like "Cannot change non-caching value."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FieldReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.PropertyReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExpectedBoundEvent(System.Object)">
            <summary>
            ArgumentTypeException with message like "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedType(System.Object,System.Object)">
            <summary>
            ArgumentTypeException with message like "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MemberWriteOnly(System.Object)">
            <summary>
            MemberAccessException with message like "can only write to member {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCodeToCompile">
            <summary>
            InvalidOperationException with message like "No code to compile."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidStreamType(System.Object)">
            <summary>
            ArgumentException with message like "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationNotStarted">
            <summary>
            InvalidOperationException with message like "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationFinished">
            <summary>
            InvalidOperationException with message like "Enumeration already finished."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddCasing(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddIdentifier(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoImplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoExplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NameNotDefined(System.Object)">
            <summary>
            MissingMemberException with message like "name '{0}' not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoDefaultValue">
            <summary>
            ArgumentException with message like "No default value for a given type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownLanguageProviderType">
            <summary>
            ArgumentException with message like "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantReadProperty">
            <summary>
            InvalidOperationException with message like "can't read from property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantWriteProperty">
            <summary>
            InvalidOperationException with message like "can't write to property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.IllegalNew_GenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekLine(System.IO.TextReader,System.Int32)">
            <summary>
            Seeks the first character of a specified line in the text stream.
            </summary>
            <param name="reader">The reader.</param>
            <param name="line">Line number. The current position is assumed to be line #1.</param>
            <returns>
            Returns <c>true</c> if the line is found, <b>false</b> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.ReadTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters to a string until end position or a terminator is reached. 
            Doesn't include the terminator into the resulting string.
            Returns <c>null</c>, if the reader is at the end position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters until end position or a terminator is reached.
            Returns <c>true</c> if the character has been found (the reader is positioned right behind the character), 
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetObjectCallSiteDelegateType(System.Int32)">
            <summary>
            Gets a Func of CallSite, object * paramCnt, object delegate type
            that's suitable for use in a non-strongly typed call site.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.IsMandatory(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.Ancestors(System.Type)">
            <summary>
            Yields all ancestors of the given type including the type itself.
            Does not include implemented interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetDeclaredInterfaces(System.Type)">
            <summary>
            Like Type.GetInterfaces, but only returns the interfaces implemented by this type
            and not its parents.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetVisibleExtensionMethodGroups(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Enumerates extension methods in given assembly. Groups the methods by declaring namespace.
            Uses a global cache if <paramref name="useCache"/> is true.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.BindGenericParameters(System.Type,System.Type,System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Binds occurances of generic parameters in <paramref name="openType"/> against corresponding types in <paramref name="closedType"/>.
            Invokes <paramref name="binder"/>(parameter, type) for each such binding.
            Returns false if the <paramref name="openType"/> is structurally different from <paramref name="closedType"/> or if the binder returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ExtensionMethodInfo.IsExtensionOf(System.Type)">
            <summary>
            Determines if a given type matches the type that the method extends. 
            The match might be non-trivial if the extended type is an open generic type with constraints.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StringUtils.SplitWords(System.String,System.Boolean,System.Int32)">
            <summary>
            Splits text and optionally indents first lines - breaks along words, not characters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.FileStreamContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
    </members>
</doc>
