<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSScriptLibrary</name>
    </assembly>
    <members>
        <member name="T:csscript.AssemblyExecutor">
            <summary>
            Executes "public static void Main(..)" of assembly in a separate domain.
            </summary>
        </member>
        <member name="T:csscript.RemoteExecutor">
            <summary>
            Invokes static method 'Main' from the assembly.
            </summary>
        </member>
        <member name="M:csscript.RemoteExecutor.ResolveEventHandler(System.Object,System.ResolveEventArgs)">
            <summary>
            AppDomain event handler. This handler will be called if CLR cannot resolve
            referenced local assemblies
            </summary>
        </member>
        <member name="T:csscript.CSharpParser">
            <summary>
            Very light parser for C# code. The main purpose of it is to be very fast and reliable.
            It only extracts code information relative to the CS-Script.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.CmdScriptInfo">
            <summary>
            Class to hold the script information on what pre- or post-execution script needs to be executed.
            pre- and post-script CS-Script command format:
            //css_prescript file([arg0][, arg1]..[,arg2])[,ignore];
            //file - script file (extension is optional)
            //arg0..N - script string arguments;
            If $this is specified as arg0..N it will be replaced with the parent script full name at execution time.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.CmdScriptInfo.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Creates an instance of CmdScriptInfo.
            </summary>
            <param name="statement">CS-Script pre- or post-script directive</param>
            <param name="preScript">If set to true the 'statement' is a pre-script otherwise it is a post-script.</param>
            <param name="parentScript">The file name of the main script.</param>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.args">
            <summary>
            Script file and it's arguments.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.preScript">
            <summary>
            If set to 'true' the CmdScriptInfo describes the pre-script, otherwise it is for the post-script.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.abortOnError">
            <summary>
            If set to 'true' parent script will be aborted on pre/post-script error, otherwise the error will be ignored.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.InitInfo">
            <summary>
            Class to hold the script initialization information.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.InitInfo.CoInitializeSecurity">
            <summary>
            The boolean flag indicating if CoInitializeSecurity (with default parameters) should be called at the start of the script execution.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.InitInfo.RpcImpLevel">
            <summary>
            The RpcImpLevel of CoInitializeSecurity arguments
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.InitInfo.EoAuthnCap">
            <summary>
            The EoAuthnCap of CoInitializeSecurity arguments
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.InitInfo.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CSharpParser.InitInfo"/> class.
            </summary>
            <param name="statement">The original argument statement of the <c>//css_init</c> directive.</param>
        </member>
        <member name="T:csscript.CSharpParser.ImportInfo">
            <summary>
            Class to hold the script importing information, which actually controls how script is imported.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.ImportInfo.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of ImportInfo.
            </summary>
            <param name="statement">CS-Script import directive (//css_import...) string.</param>
            <param name="parentScript">name of the parent (primary) script file.</param>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.file">
            <summary>
            The file to be imported.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.renaming">
            <summary>
            Renaming instructions (old_name vs. new_name)
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.preserveMain">
            <summary>
            If set to 'true' "static...Main" in the imported script is not renamed.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="code">C# code string</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean,System.String[],System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
            <param name="probingDirs">Search directories for resolving wild card paths in //css_inc and //css_imp</param>
        </member>
        <member name="F:csscript.CSharpParser.CustomDirectives">
            <summary>
            The result of search for additional C# script directives to search (directive vs. value).
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.Init(System.String,System.String,System.String[],System.String[])">
            <summary>
            Parses the C# code.
            </summary>
            <param name="code">C# script (code or file).</param>
            <param name="file">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
            <param name="probingDirs">Search directories for resolving wild card paths in //css_inc and //css_imp</param>
        </member>
        <member name="M:csscript.CSharpParser.DoRenaming(System.String[][],System.Boolean)">
            <summary>
            Renames namespaces according renaming instructions.
            </summary>
            <param name="renamingMap">Renaming instructions (old_name vs. new_name).</param>
            <param name="preserveMain">/// If set to 'true' "static...Main" in the imported script is not renamed.</param>
        </member>
        <member name="P:csscript.CSharpParser.Args">
            <summary>
            Embedded script arguments. The both script and engine arguments are allowed except "/noconfig" engine command line switch.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CompilerOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.HostOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Precompilers">
            <summary>
            Precompilers.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.References">
            <summary>
            References to the external assemblies and namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefAssemblies">
            <summary>
            References to the external assemblies.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.IgnoreNamespaces">
            <summary>
            Names of namespaces to be ignored by namespace-to-assembly resolver.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ExtraSearchDirs">
            <summary>
            Additional search directories (for script and assembly probing).
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ResFiles">
            <summary>
            References to the resource files.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefNamespaces">
            <summary>
            References to the namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.NuGets">
            <summary>
            References to the NuGet packages.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Imports">
            <summary>
            C# scripts to be imported.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CmdScripts">
            <summary>
            Pre- and post-execution scripts.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Inits">
            <summary>
            Script initialization directives.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ThreadingModel">
            <summary>
            Apartment state of the script.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Code">
            <summary>
            Script C# raw code.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ModifiedCode">
            <summary>
            Script C# code after namespace renaming.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.OpenEndDirectiveSyntax">
            <summary>
            Enables omitting closing character (";") for CS-Script directives (e.g. "//css_ref System.Xml.dll" instead of "//css_ref System.Xml.dll;").
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.EscapeDirectiveDelimiters(System.String)">
            <summary>
            Escapes the CS-Script directive (e.g. //css_*) delimiters.
            <para>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character. 
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters. 
            The correct syntax would be as follows '//css_include script((today)).cs;'</para>
            <remarks>The delimiters characters are ';,(){}'.
            <para>However you should check <see cref="F:csscript.CSharpParser.DirectiveDelimiters"/> for the accurate list of all delimiters.
            </para> 
            </remarks>
            </summary>
            <param name="text">The text to be processed.</param>
            <returns></returns>
        </member>
        <member name="M:csscript.CSharpParser.UnescapeDirectiveDelimiters(System.String)">
            <summary>
            Unescapes the CS-Script directive (e.g. //css_*) delimiters.
            <para>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character. 
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters. 
            The correct syntax would be as follows '//css_include script((today)).cs;'</para>
            <remarks>The delimiters characters are ';,(){}'.
            <para>However you should check <see cref="F:csscript.CSharpParser.DirectiveDelimiters"/> for the accurate list of all delimiters.
            </para> 
            </remarks>
            </summary>
            <param name="text">The text to be processed.</param>
            <returns></returns>
        </member>
        <member name="F:csscript.CSharpParser.DirectiveDelimiters">
            <summary>
            The //css_* directive delimiters. 
            <remarks>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character. 
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters. 
            The correct syntax would be as follows '//css_include script((today)).cs;'
            </remarks>
            </summary>
        </member>
        <member name="T:csscript.ResolveSourceFileHandler">
            <summary>
            Delegate implementing source file probing algorithm.
            </summary>
            <param name="file">The file.</param>
            <param name="searchDirs">The extra dirs.</param>
            <param name="throwOnError">if set to <c>true</c> [throw on error].</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ResolveSourceFileAlgorithm">
            <summary>
            Delegate implementing source file probing algorithm.
            </summary>
            <param name="file">The file.</param>
            <param name="searchDirs">The extra dirs.</param>
            <param name="throwOnError">if set to <c>true</c> [throw on error].</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ResolveAssemblyHandler">
            <summary>
            Delegate implementing assembly file probing algorithm.
            </summary>
            <param name="file">The file.</param>
            <param name="searchDirs">The extra dirs.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.CSExecutor">
            <summary>
            CSExecutor is an class that implements execution of *.cs files.
            </summary>
        </member>
        <member name="P:csscript.CSExecutor.Rethrow">
            <summary>
            Force caught exceptions to be rethrown.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Execute(System.String[],csscript.PrintDelegate,System.String)">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetCustomAppConfig(System.String[])">
            <summary>
            Returns custom application config file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.VoidPrint(System.String)">
            <summary>
            Dummy 'print' to suppress displaying application messages.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.lastException">
            <summary>
            This method implements compiling and execution of the script.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ExecuteImpl">
            <summary>
            This method implements compiling and execution of the script.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String,System.String,System.Boolean)">
            <summary>
            Compiles C# script file into assembly.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.scriptArgs">
            <summary>
            C# Script arguments array (sub array of application arguments array).
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.print">
            <summary>
            Callback to print application messages to appropriate output.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.options">
            <summary>
            Container for parsed command line arguments
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.rethrow">
            <summary>
            Flag to force to rethrow critical exceptions
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor(System.Boolean,csscript.ExecuteOptions)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetAvailableAssembly(System.String)">
            <summary>
            Checks/returns if compiled C# script file (ScriptName + ".compiled") available and valid.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String)">
            <summary>
            Compiles C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempDir">
            <summary>
            Returns the name of the temporary folder in the CSSCRIPT subfolder of Path.GetTempPath().
            <para>Under certain circumstances it may be desirable to the use the alternative location for the CS-Script temporary files.
            In such cases use SetScriptTempDir() to set the alternative location.
            </para>
            </summary>
            <returns>Temporary directory name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.SetScriptTempDir(System.String)">
            <summary>
            Sets the location for the CS-Script temporary files directory.
            </summary>
            <param name="path">The path for the temporary directory.</param>
        </member>
        <member name="M:csscript.CSExecutor.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="P:csscript.CSExecutor.ScriptCacheDir">
            <summary>
             Contains the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specific for every script file.
             </summary>
        </member>
        <member name="M:csscript.CSExecutor.SetScriptCacheDir(System.String)">
            <summary>
            Generates the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specific for every script file.
            </summary>
            <param name="scriptFile">script file</param>
        </member>
        <member name="M:csscript.CSExecutor.ShowHelp">
            <summary>
            Prints Help info.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowSample">
            <summary>
            Show sample C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowPrecompilerSample">
            <summary>
            Show sample precompiler C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.CreateDefaultConfigFile">
            <summary>
            Creates the default config file in the CurrentDirectory.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowVersion">
            <summary>
            Show CS-Script version information.
            </summary>
        </member>
        <member name="T:csscript.CompilerException">
            <summary>
            The exception that is thrown when a the script compiler error occurs.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="M:csscript.CompilerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:csscript.CompilerException.Create(System.CodeDom.Compiler.CompilerErrorCollection,System.Boolean)">
            <summary>
            Creates the CompilerException instance from the specified compiler errors.
            </summary>
            <param name="Errors">The compiler errors.</param>
            <param name="hideCompilerWarnings">if set to <c>true</c> hide compiler warnings.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ExecuteOptions">
            <summary>
            Application specific runtime settings
            </summary>
        </member>
        <member name="T:csscript.COM">
            <summary>
            COM HR checker: just to make code more compact;
            </summary>
        </member>
        <member name="T:csscript.IAssemblyCache">
            <summary>
            IAssemblyCache; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyName">
            <summary>
            IAssemblyName; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyEnum">
            <summary>
            IAssemblyEnum; COM import
            </summary>
        </member>
        <member name="T:csscript.AssemblyCommitFlags">
            <summary>
            AssemblyCommitFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheFlags">
            <summary>
            AssemblyCacheFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheUninstallDisposition">
            <summary>
            AssemblyCacheUninstallDisposition; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.CreateAssemblyNameObjectFlags">
            <summary>
            CreateAssemblyNameObjectFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyNameDisplayFlags">
            <summary>
            AssemblyNameDisplayFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReference">
            <summary>
            InstallReference + struct initialization; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyInfo">
            <summary>
            AssemblyInfo; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReferenceGuid">
            <summary>
            InstallReferenceGuid; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCache">
            <summary>
             Helper calss for IAssemblyCache
            </summary>
        </member>
        <member name="T:csscript.AssemblyEnum">
            <summary>
            Helper calss for IAssemblyEnum
            </summary>
        </member>
        <member name="T:csscript.PrecompilationContext">
            <summary>
            This class is a container for information related to the script precompilation.
            <para>It is used to pass an input information from the script engine to the <c>precompiler</c> instance as well as to pass back
            to the script engine some output information (e.g. added referenced assemblies)</para> .
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewReferences">
            <summary>
            Collection of the referenced assemblies to be added to the process script referenced assemblies.
            <para>You may want to add new items to the referenced assemblies because of the precompilation logic (e.g. some code using assemblies not referenced by the primary script 
            is injected in the script).</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewDependencies">
            <summary>
            Collection of the new dependency items (files). 
            <para>Dependency files are checked before the script execution in order to understand if the script should be recompiled or it can be loaded from 
            the cache. If any of the dependency files is changed since the last script execution the script engine will recompile the script. In the simple execution 
            scenarios the script file is a dependency file.</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewIncludes">
            <summary>
            Collection of the new 'include' items (dependency source files). 
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewSearchDirs">
            <summary>
            Collection of the assembly and script probing directories to be added to the process search directories.
            <para>You may want to add new items to the process search directories because of the precompilation logic.</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.SearchDirs">
            <summary>
            Collection of the process assembly and script probing directories.
            </summary>
        </member>
        <member name="T:csscript.AutoclassGenerator">
            <summary>
            AutoclassGenerator to be used by external applications for generating the auto-class from the classless scripts
            </summary>
        </member>
        <member name="M:csscript.AutoclassGenerator.Process(System.String,System.Int32@,System.Int32@)">
            <summary>
            Processes the specified code.
            </summary>
            <param name="code">The code.</param>
            <param name="injectionPos">The injection position.</param>
            <param name="injectionLength">Length of the injection.</param>
            <returns></returns>
        </member>
        <member name="M:csscript.AutoclassGenerator.Process(System.String,System.Int32@)">
            <summary>
            Processes the specified code.
            </summary>
            <param name="code">The code.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="F:csscript.AutoclassGenerator.ConsoleEncoding">
            <summary>
            The console encoding to be set for at the script initialization.
            </summary>
        </member>
        <member name="T:csscript.Settings">
            <summary>
            Settings is an class that holds CS-Script application settings.
            </summary>
        </member>
        <member name="P:csscript.Settings.CleanupShellCommand">
             <summary>
             Command to be executed to perform custom cleanup.
             If this value is empty automatic cleanup of all
             temporary files will occurs after the script execution.
             This implies that the script has to be executed in the
             separate AppDomain and some performance penalty will be incurred.
            
             Setting this value to the command for custom cleanup application
             (e.g. csc.exe cleanTemp.cs) will force the script engine to execute
             script in the 'current' AppDomain what will improve performance.
             </summary>
        </member>
        <member name="M:csscript.Settings.ExpandCleanupShellCommand">
            <summary>
            Returns value of the CleanupShellCommand (with expanding environment variables).
            </summary>
            <returns>shell command string</returns>
        </member>
        <member name="P:csscript.Settings.DoCleanupAfterNumberOfRuns">
            <summary>
            This value indicates frequency of the custom cleanup
            operation. It has affect only if CleanupShellCommand is not empty.
            </summary>
        </member>
        <member name="P:csscript.Settings.UseAlternativeCompiler">
            <summary>
            Location of alternative code provider assembly. If set it forces script engine to use an alternative code compiler.
            </summary>
        </member>
        <member name="M:csscript.Settings.ExpandUseAlternativeCompiler">
            <summary>
            Returns value of the UseAlternativeCompiler (with expanding environment variables).
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="P:csscript.Settings.UsePostProcessor">
            <summary>
            Location of PostProcessor assembly. If set it forces script engine to pass compiled script through PostProcessor before the execution.
            </summary>
        </member>
        <member name="M:csscript.Settings.ExpandUsePostProcessor">
            <summary>
            Returns value of the UsePostProcessor (with expanding environment variables).
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="P:csscript.Settings.DefaultApartmentState">
            <summary>
            DefaultApartmentState is an ApartmemntState, which will be used
            at run-time if none specified in the code with COM threading model attributes.
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultArguments">
            <summary>
            Default command-line arguments. For example if "/dbg" is specified all scripts will be compiled in debug mode
            regardless if the user specified "/dbg" when a particular script is launched.
            </summary>
        </member>
        <member name="P:csscript.Settings.OpenEndDirectiveSyntax">
            <summary>
            Enables omitting closing character (";") for CS-Script directives (e.g. "//css_ref System.Xml.dll" instead of "//css_ref System.Xml.dll;").
            </summary>
        </member>
        <member name="P:csscript.Settings.ConsoleEncoding">
            <summary>
            Encoding of he Console Output. Applicable for console applications script engine only.
            </summary>
        </member>
        <member name="P:csscript.Settings.TargetFramework">
            <summary>
            Specifies the .NET Framework version that the script is compiled against. This option can have the following values:
              v2.0
              v3.0
              v3.5
              v4.0
            </summary>
        </member>
        <member name="P:csscript.Settings.CompilerFramework">
            <summary>
            Specifies the .NET Framework version that the script is compiled against. This option can have the following values:
              v2.0
              v3.0
              v3.5
              v4.0
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultRefAssemblies">
            <summary>
            List of assembly names to be automatically referenced by the script. The items must be separated by coma or semicolon. Specifying .dll extension (e.g. System.Core.dll) is optional.
            Assembly can contain expandable environment variables.
            </summary>
        </member>
        <member name="M:csscript.Settings.ExpandDefaultRefAssemblies">
            <summary>
            Returns value of the DefaultRefAssemblies (with expanding environment variables).
            </summary>
            <returns>List of assembly names</returns>
        </member>
        <member name="P:csscript.Settings.SearchDirs">
            <summary>
            List of directories to be used to search (probing) for referenced assemblies and script files.
            This setting is similar to the system environment variable PATH.
            </summary>
        </member>
        <member name="M:csscript.Settings.AddSearchDir(System.String)">
            <summary>
            Add search directory to the search (probing) path Settings.SearchDirs.
            For example if Settings.SearchDirs = "c:\scripts" then after call Settings.AddSearchDir("c:\temp") Settings.SearchDirs is "c:\scripts;c:\temp"
            </summary>
            <param name="dir">Directory path.</param>
        </member>
        <member name="P:csscript.Settings.HideAutoGeneratedFiles">
            <summary>
            The value, which indicates if auto-generated files (if any) should should be hidden in the temporary directory.
            </summary>
        </member>
        <member name="P:csscript.Settings.Precompiler">
            <summary>
            Path to the precompiller script/assembly (see documentation for details). You can specify multiple recompiles separating them by semicolon.
            </summary>
        </member>
        <member name="P:csscript.Settings.CustomHashing">
            <summary>
            Gets or sets a value indicating whether custom string hashing algorithm should be used.
            <para>
            String hashing is used by the script engine for allocating temporary and cached paths. 
            However default string hashing is platform dependent (x32 vs. x64) what makes impossible 
            truly deterministic string hashing. This in turns complicates the integration of the 
            CS-Script infrastructure with the third-party applications (e.g. Notepad++ CS-Script plugin).
            </para>
            <para>
            To overcome this problem CS-Script uses custom string hashing algorithm (default setting).
            Though the native .NET hashing can be enabled if desired by setting <c>CustomHashing</c>
            to <c>false</c>.</para>
            </summary>
            <value>
              <c>true</c> if custom hashing is in use; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:csscript.Settings.HideOptions">
            <summary>
            Enum for possible hide auto-generated files scenarios
            Note: when HideAll is used it is responsibility of the pre/post script to implement actual hiding.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.DoNotHide">
            <summary>
            Do not hide auto-generated files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideMostFiles">
            <summary>
            Hide the most of the auto-generated (cache and "imported") files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideAll">
            <summary>
            Hide all auto-generated files including the files generated by pre/post scripts.
            </summary>
        </member>
        <member name="P:csscript.Settings.ReportDetailedErrorInfo">
            <summary>
            Boolean flag that indicates how much error details to be reported should error occur.
            false - Top level exception will be reported
            true - Whole exception stack will be reported
            </summary>
        </member>
        <member name="P:csscript.Settings.OptimisticConcurrencyModel">
            <summary>
            Gets or sets a value indicating whether Optimistic Concurrency model should be used when executing scripts from the host application.
            If set to <c>false</c> the script loading (not the execution) is globally thread-safe. If set to <c>true</c> the script loading is
            thread-safe only among loading operations for the same script file.
            <para>The default value is <c>true</c>.</para>
            </summary>
            <value>
            	<c>true</c> if Optimistic Concurrency model otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:csscript.Settings.HideCompilerWarnings">
            <summary>
            Boolean flag that indicates if compiler warnings should be included in script compilation output.
            false - warnings will be displayed
            true - warnings will not be displayed
            </summary>
        </member>
        <member name="P:csscript.Settings.InMemoryAssembly">
            <summary>
            Boolean flag that indicates the script assembly is to be loaded by CLR as an in-memory byte stream instead of the file.
            This setting can be useful when you need to prevent script assembly (compiled script) from locking by CLR during the execution.
            false - script assembly will be loaded as a file. It is an equivalent of Assembly.LoadFrom(string assemblyFile).
            true - script assembly will be loaded as a file. It is an equivalent of Assembly.Load(byte[] rawAssembly)
            </summary>
        </member>
        <member name="M:csscript.Settings.Save(System.String)">
            <summary>
            Saves CS-Script application settings to a file (.dat).
            </summary>
            <param name="fileName">File name of the .dat file</param>
        </member>
        <member name="M:csscript.Settings.Load(System.String)">
            <summary>
            Loads CS-Script application settings from a file. Default settings object is returned if it cannot be loaded from the file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <returns>Setting object deserilized from the XML file</returns>
        </member>
        <member name="M:csscript.Settings.Load(System.String,System.Boolean)">
            <summary>
            Loads CS-Script application settings from a file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <param name="createAlways">Create and return default settings object if it cannot be loaded from the file.</param>
            <returns>Setting object deserialized from the XML file</returns>
        </member>
        <member name="M:csscript.Utils.WaitForFileIdle(System.String,System.Int32)">
            <summary>
            Waits for file idle.
            </summary>
            <param name="file">The file.</param>
            <param name="delay">The delay.</param>
            <returns><c>true</c> if the wait is successful.</returns>
        </member>
        <member name="M:csscript.Utils.AddCompilerOptions(System.CodeDom.Compiler.CompilerParameters,System.String)">
            <summary>
            Adds compiler options to the CompilerParameters in a manner that it does separate every option by the space character
            </summary>
        </member>
        <member name="M:csscript.CSSUtils.ParseAppArgs(System.String[],csscript.IScriptExecutor)">
            <summary>
            Parses application (script engine) arguments.
            </summary>
            <param name="args">Arguments</param>
            <param name="executor">Script executor instance</param>
            <returns>Index of the first script argument.</returns>
        </member>
        <member name="T:csscript.MetaDataItems">
             <summary>
             The MetaDataItems class contains information about script dependencies (referenced local
             assemblies and imported scripts) and compiler options. This information is required when
             scripts are executed in a 'cached' mode (/c switch). On the base of this information the script
             engine will compile new version of .compiled assembly if any of it's dependencies is changed. This
             is required even for referenced local assemblies as it is possible that they are a strongly
             named assemblies (recompiling is required for any compiled client of the strongly named assembly
             in case this assembly is changed).
            
             The perfect place to store the dependencies info (custom meta data) is the assembly
             resources. However if we do so such assemblies would have to be loaded in order to read their
             resources. It is not acceptable as after loading assembly cannot be unloaded. Also assembly loading
             can significantly compromise performance.
            
             That is why custom meta data is just physically appended to the file. This is a valid
             approach because such assembly is not to be distributed anywhere but to stay always
             on the PC and play the role of the temporary data for the script engine.
            
             Note: A .dll assembly is always compiled and linked in a normal way without any custom meta data attached.
             </summary>
        </member>
        <member name="T:csscript.CSSEnvironment">
            <summary>
            This class implements access to the CS-Script global configuration settings.
            </summary>
        </member>
        <member name="M:csscript.CSSEnvironment.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.SaveAsTempScript(System.String)">
            <summary>
            Saves code to the script file in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete the script file after the execution.
            It will be deleted as part of the periodical automatic CS-Script maintenance.
            </summary>
            <param name="content">The script file content.</param>
            <returns>Name of the created temporary script file.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.GetTempScriptName">
            <summary>
            Generates the script file path in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete such file after the execution.
            It will be deleted as part of the periodical automatic CS-Script maintenance.
            </summary>
            <returns>Name of the temporary script file.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.SetScriptTempDir(System.String)">
            <summary>
            Sets the location for the CS-Script temporary files directory.
            </summary>
            <param name="path">The path for the temporary directory.</param>
        </member>
        <member name="P:csscript.CSSEnvironment.ScriptFile">
            <summary>
            The full name of the script file being executed.
            </summary>
        </member>
        <member name="P:csscript.CSSEnvironment.PrimaryScriptFile">
            <summary>
            The full name of the primary script file being executed. Usually it is the same file as ScriptFile.
            However these fields are different if analyzed from the pre/post-script.
            </summary>
        </member>
        <member name="T:csscript.AppInfo">
            <summary>
            Repository for application specific data
            </summary>
        </member>
        <member name="T:CSScriptLibrary.AssemblyResolver">
            <summary>
            Class for resolving assembly name to assembly file
            </summary>
        </member>
        <member name="F:CSScriptLibrary.AssemblyResolver.ignoreFileName">
            <summary>
            File to be excluded from assembly search
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AssemblyResolver.CacheProbingResults">
            <summary>
            Gets or sets a value indicating whether the assembly probing results should be cached. Default value is <c>false</c>;
            <para>
            Caching means that during the probing if the assembly is not found in one of the probing directories this directory will not
            be checked again if the same assembly is to be resolved in the future.
            </para>
            <para>
            This setting is to be used with the caution. While it can bring some performance benefits when the list of probing directories
            is large it also may be wrong to assume that if the assembly in not found in a particular directory it still will not be there if the probing is repeated.
            </para>
            </summary>
            <value><c>true</c> if probing results should be cached; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.ResolveAssembly(System.String,System.String,System.Boolean)">
            <summary>
            Resolves assembly name to assembly file. Loads assembly file to the current AppDomain.
            </summary>
            <param name="assemblyName">The name of assembly</param>
            <param name="dir">The name of directory where local assemblies are expected to be</param>
            <param name="throwExceptions">if set to <c>true</c> [throw exceptions].</param>
            <returns>loaded assembly</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.IsLegalPathToken(System.String)">
            <summary>
            Determines whether the string is a legal path token.
            </summary>
            <param name="name">The name.</param>
            <returns>
            	<c>true</c> if the string is a legal path token; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindAssembly(System.String,System.String[])">
            <summary>
            Resolves namespace/assembly(file) name into array of assembly locations (local and GAC ones).
            </summary>
            <param name="name">'namespace'/assembly(file) name</param>
            <param name="searchDirs">Assembly search directories</param>
            <para>If the default implementation isn't suitable then you can set <c>CSScript.FindAssemblyAlgorithm</c> 
            to the alternative implementation of the probing algorithm.</para>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindLocalAssembly(System.String,System.String)">
            <summary>
            Resolves namespace into array of local assembly locations.
            (Currently it returns only one assembly location but in future
            it can be extended to collect all assemblies with the same namespace)
            </summary>
            <param name="name">namespace/assembly name</param>
            <param name="dir">directory</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindGlobalAssembly(System.String)">
            <summary>
            Resolves namespace into array of global assembly (GAC) locations.
            </summary>
            <param name="namespaceStr">'namespace' name</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.IsNamespaceDefinedInAssembly(System.String,System.String)">
            <summary>
            Search for namespace into local assembly file.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ParsingParams">
            <summary>
            ParsingParams is an class that holds parsing parameters (parameters that controls how file is to be parsed).
            At this moment they are namespace renaming rules only.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ParsingParams.Compare(CSScriptLibrary.ParsingParams,CSScriptLibrary.ParsingParams)">
            <summary>
            Compare() is to be used to help with implementation of IComparer for sorting operations.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ScriptInfo">
            <summary>
            Class which is a placeholder for general information of the script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptInfo.#ctor(csscript.CSharpParser.ImportInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">ImportInfo object containing the information how the script file should be parsed.</param>
        </member>
        <member name="T:CSScriptLibrary.FileParser">
            <summary>
            Class that implements parsing the single C# script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[])">
            <summary>
            Searches for script file by given script name. Calls ResolveFile(string fileName, string[] extraDirs, bool throwOnError)
            with throwOnError flag set to true.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.FileParser.ResolveFileAlgorithm">
            <summary>
            The resolve file algorithm,
            <para>
            The default algorithm searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_DIR%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[],System.Boolean)">
            <summary>
            Searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_DIR%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            <para>If the default implementation isn't suitable then you can set <c>FileParser.ResolveFileAlgorithm</c> 
            to the alternative implementation of the probing algorithm.</para>
            </summary>
        </member>
        <member name="T:CSScriptLibrary.FileParserComparer">
             <summary>
             Class that implements parsing the single C# Script file
             </summary>
             <summary>
             Implementation of the IComparer for sorting operations of collections of FileParser instances
             </summary>
            
        </member>
        <member name="T:CSScriptLibrary.ScriptParser">
            <summary>
            Class that manages parsing the main and all imported (if any) C# Script files
            </summary>
        </member>
        <member name="F:CSScriptLibrary.ScriptParser.apartmentState">
            <summary>
            ApartmentState of a script during the execution (default: ApartmentState.Unknown)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.FilesToCompile">
            <summary>
            Collection of the files to be compiled (including dependent scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ImportedFiles">
            <summary>
            Collection of the imported files (dependant scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedResources">
            <summary>
            Collection of resource files referenced from code
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.CompilerOptions">
            <summary>
            Collection of compiler options
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.Precompilers">
            <summary>
            Precompilers specified in the primary script file.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedNamespaces">
            <summary>
            Collection of namespaces referenced from code (including those referenced in dependand scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.IgnoreNamespaces">
            <summary>
            Collection of namespaces, which if found in code, should not be resolved into referenced assembly.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.ResolvePackages(System.Boolean)">
            <summary>
            Resolves the NuGet packages into assemblies to be referenced by the script.
            <para>If the package was never installed/downloaded yet CS-Script runtime will try to download it.</para>
            <para>CS-Script will also analyze the installed package structure in try to reference compatible assemblies
            from the package.</para>
            </summary>
            <param name="suppressDownloading">if set to <c>true</c> suppresses downloading the NuGet package. 
            Suppressing can be useful for the quick 'referencing' assessment.</param>
            <returns>Collection of the referenced assembly files.</returns>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.Packages">
            <summary>
            Collection of the NuGet packages
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedAssemblies">
            <summary>
            Collection of referenced assemblies. All assemblies are referenced either from command-line, code or resolved from referenced namespaces.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[])">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[],System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
            <param name="throwOnError">flag to indicate if the file parsing/processing error should raise an exception</param>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ScriptPath">
            <summary>
            The path of the parsed script.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.Init(System.String,System.String[])">
            <summary>
            Initialization of ScriptParser instance
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.SaveImportedScripts">
            <summary>
            Saves all imported scripts int temporary location.
            </summary>
            <returns>Collection of the saved imported scrips file names</returns>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.DeleteImportedFiles">
            <summary>
            Deletes imported scripts as a cleanup operation
            </summary>
        </member>
        <member name="F:CSScriptLibrary.ScriptParser.SearchDirs">
            <summary>
            CS-Script SearchDirectories specified in the parsed script or its dependent scripts.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.FastInvokeDelegate">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().
            
             AsmHelper.GetMethodInvoker() allows obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <param name="instance">Instance of the type which method is to be invoked.</param>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.MethodDelegate">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().
            
             AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.MethodDelegate`1">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().
            
             AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.AsmHelper">
            <summary>
            Helper class to simplify working with dynamically loaded assemblies.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/></param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateAndAlignToInterface``1(System.String,System.Object[])">
            <summary>
            Creates object in remote or current <see cref="T:System.AppDomain"/> and aligns (pseudo typecasts) it to the specified interface.
            <para>Semantically it is an equivalent of calling
            <code>asmHelper.AlignToInterface(asmHelper.CreateObject(typeName))</code>
            </para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ScriptExecutionDomain">
            <summary>
            Instance of the AppDomain, which is used to execute the script.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.RemoteObject">
            <summary>
            Reference to the <see cref="T:CSScriptLibrary.AsmHelper"/> "worker" object created in the remote AppDomain. This property is null
            unless <see cref="T:CSScriptLibrary.AsmHelper"/> was instantiated for the <c>remote execution</c> scenario.
            <para>This property can be useful when you need to access the remote object in order to manage the "life time" of the AsmHelper in
            Remoting and WCF scenarios.</para>
            </summary>
            <example>
            <code>
            var scriptHelper = new AsmHelper(scriptAsmFile, null, true);
            scriptHelper.RemoteObject.ExtendLifeFromMinutes(30);
            </code>
            </example>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.CachingEnabled">
            <summary>
            Flag that indicates if method caching is enabled. It is set to true by default.
            <para></para>
            When caching is enabled AsmHelper generates (emits) extremely fast delegates for
            the methods being invoked. If AsmHelper is in cache mode it performs more than twice faster.
            However generation of the delegate does take some time that is why you may consider
            switching caching off if the method is to be invoked only once.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethodInvoker(System.String,System.Object[])">
            <summary>
            This method returns extremely fast delegate for the method specified by "methodName" and
            method arguments "list". Invoking such delegate is ~100 times faster than invoking with pure reflection
            (MethodInfo.Invoke()).
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments.
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <para></para>
            GetMethodInvoker("Calc.Sum", 0, 0)
            <para></para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.FastInvokeDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod(System.String,System.Object[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
            <remarks>
            <para>
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            </para>
            </para>
            <example>
            <code>GetStaticMethod("Calc.Sum", 0, 0)</code>
            </example>
            <para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </remarks>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod``1(System.String,System.Object[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
            <remarks>
            <para>
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            </para>
            </para>
            <example>
            <code>GetStaticMethod("Calc.Sum", 0, 0)</code>
            </example>
            <para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </remarks>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethodWithArgs(System.String,System.Type[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethodWithArgs``1(System.String,System.Type[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
            underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            <para>
            Use this method when script assembly contains only one single type with one method.
            </para>
            </summary>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod``1">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
            underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            <para>
            Use this method when script assembly contains only one single type with one method.
            </para>
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethod(System.Object,System.String,System.Object[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance when calling instance methods as delegate will maintain the instance object internally.
            </summary>
            <param name="instance">Instance of the type, which implements method is to be wrapped by MethodDelegate.</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments.
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <code>
            GetMethod(instance, "Sum", 0, 0)
            </code>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethod``1(System.Object,System.String,System.Object[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance when calling instance methods as delegate will maintain the instance object internally.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="instance">Instance of the type, which implements method is to be wrapped by MethodDelegate.</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments.
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <code>
            GetMethod(instance, "Sum", 0, 0)
            </code>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.Reflection.Assembly)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to current AppDomain.
            Calling "Dispose" is optional for "current AppDomain"scenario as no new AppDomain will be ever created.
            </summary>
            <param name="asm">Assembly object.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to non-current AppDomain.
            This method initializes instance and creates new ('remote') AppDomain with 'domainName' name. New AppDomain is automatically unloaded as result of "disposable" behaviour of AsmHelper.
            </summary>
            <param name="asmFile">File name of the assembly to be loaded.</param>
            <param name="domainName">Name of the domain to be created.</param>
            <param name="deleteOnExit">'true' if assembly file should be deleted when new AppDomain is unloaded; otherwise, 'false'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Invoke(System.String,System.Object[])">
            <summary>
            Executes static method of the underlying assembly.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (e.g. MyType.DoJob). It is allowed to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.InvokeInst(System.Object,System.String,System.Object[])">
            <summary>
            Executes an instance method of the underlying assembly.
            </summary>
            <param name="obj">Instance of the object whose method is to be invoked.</param>
            <param name="methodName">'Method' name (excluding 'Type' name). It is allowed to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even "*.*").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMembersOf(System.Object)">
            <summary>
            Gets the information about the object members.
            <p>This is an extremely light way of getting Reflection information of a given object. Object can be either local one
            or a TransparentProxy of the object instantiated in a remote AppDomain.</p>
            <remarks>Note: Because none of the MemberInfo derivatives is serializable. This makes it impossible to use Reflection
            for discovering the type members instantiated in the different AppDomains. And the TransparentProxies do not provide any marshaled
            Reflection API neither.
            </remarks>
            <example>
            <code>
            using (var helper = new AsmHelper(CSScript.CompileCode(code), null, true))
            {
                var script = helper.CreateObject("Script"); //script code has 'class Script' declared
                foreach (string info in helper.GetMembersOf(script))
                    Debug.WriteLine(info);
            }
            </code>
            </example>
            </summary>
            <param name="obj">The object.</param>
            <returns>Collection of strings with each item representing human readable information about the Type member.
            <para>
            <c>Type implementation:</c><code>
            class Script
            {
                public void SayHello(string greeting)
                {
                    ...
            </code>
            </para>
            <para>
            <para><c>Type member information:</c> </para>
            "MemberType:Method;Name:SayHello;DeclaringType:Script;Signature:Void SayHello(System.String)"
            </para>
            </returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.TryCreateObject(System.String,System.Object[])">
            <summary>
            Attempts to create instance of a class from underlying assembly.
            </summary>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateObject(System.String,System.Object[])">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Unload">
            <summary>
            Unloads 'remote' AppDomain if it was created.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose">
            <summary>
            Implementation of IDisposable.Dispose(). Disposes allocated external resources if any. Call this method to unload non-current AppDomain (if it was created).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose(System.Boolean)">
            <summary>
            Actual implementation of IDisposable.Dispose()
            </summary>
            <param name="disposing">'false' if the method has been called by the runtime from inside the finalizer ; otherwise, 'true'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ProbingDirs">
             <summary>
            Array of directories to be used for assembly probing.
             </summary>
        </member>
        <member name="T:CSScriptLibrary.IAsmBrowser">
            <summary>
            Defines method for calling assembly methods and instantiating assembly types.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmBrowser.CreateInstance(System.String,System.Object[])">
            <summary>
            Creates instance of a Type from underlying assembly.
            </summary>
            <param name="typeName">Name of the type to be instantiated. Allows wild card character (e.g. *.MyClass can be used to instantiate MyNamespace.MyClass).</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>Created instance of the type.</returns>
        </member>
        <member name="T:CSScriptLibrary.FastInvoker">
             <summary>
             Class which is capable of emitting the dynamic method delegate based on the MethodInfo. Such delegate is
             extremely fast and it can demonstrate up to 100 times better performance comparing to the pure
             Reflection method invokation (MethodInfo.Invoke()).
            
            
             Based on http://www.codeproject.com/KB/cs/FastInvokerWrapper.aspx
             </summary>
        </member>
        <member name="F:CSScriptLibrary.FastInvoker.info">
            <summary>
            MethodInfo instance which was used to generate dynamic method delegate.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">MethodInfo instance which is to be used to generate dynamic method delegate.</param>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes dynamic method delegate generated from the MethodInfo object.
            </summary>
            <param name="instance">Instance of the type which method is to be invoked.</param>
            <param name="paramters">Optional method parameters.</param>
            <returns>Invokes dynamic method delegate return value</returns>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.GetMethodInvoker">
            <summary>
            Returns dynamic method delegate generated from the MethodInfo object.
            </summary>
            <returns>FastInvokeDelegate instance.</returns>
        </member>
        <member name="T:CSScriptLibrary.CSScript">
            <summary>
            Class which is implements CS-Script class library interface.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.CodeDomEvaluator">
            <summary>
            Global instance of <see cref="T:CSScriptLibrary.CodeDomEvaluator"/>. This object is to be used for
            dynamic loading of the  C# code by using Roslyn "compiler as service".
            <para>If you need to use multiple instances of th evaluator then you will need to call 
            <see cref="T:CSScriptLibrary.IEvaluator"/>.Clone().
            </para>
            </summary>
            <value> The <see cref="T:CSScriptLibrary.CodeDomEvaluator"/> instance.</value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.RoslynEvaluator">
            <summary>
            Global instance of <see cref="T:CSScriptLibrary.RoslynEvaluator"/>. This object is to be used for
            dynamic loading of the  C# code by using Roslyn "compiler as service".
            <para>If you need to use multiple instances of th evaluator then you will need to call 
            <see cref="T:CSScriptLibrary.IEvaluator"/>.Clone().
            </para>
            </summary>
            <value> The <see cref="T:CSScriptLibrary.RoslynEvaluator"/> instance.</value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.EvaluatorConfig">
            <summary>
            Gets the CSScript.<see cref="T:CSScriptLibrary.EvaluatorConfig"/>, which controls the way code evaluation is conducted at runtime.
            </summary>
            <value>The evaluator CSScript.<see cref="T:CSScriptLibrary.EvaluatorConfig"/>.</value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.Evaluator">
             <summary>
             Global instance of the generic <see cref="T:CSScriptLibrary.IEvaluator"/>. This object is to be used for
             dynamic loading of the  C# code by "compiler as service" based on the 
             <see cref="P:CSScriptLibrary.CSScript.EvaluatorConfig.Engine"/> value.
             <para>Generic <see cref="T:CSScriptLibrary.IEvaluator"/> interface provides a convenient way of accessing 
             compilers without 'committing' to a specific compiler technology (e.g. Mono, Roslyn, CodeDOM). This may be 
             required during troubleshooting or performance tuning.</para>
             <para>Switching between compilers can be done via global CSScript.<see cref="P:CSScriptLibrary.CSScript.EvaluatorConfig.Engine"/>.</para>
             </summary>
             <value>The <see cref="T:CSScriptLibrary.MonoEvaluator"/> instance.</value>
             <example>
            <code>
             if(testingWithMono)
                 CSScript.EvaluatorConfig.Engine = EvaluatorEngine.Mono;
             else
                 CSScript.EvaluatorConfig.Engine = EvaluatorEngine.Roslyn;
                 
             var sub = CSScript.Evaluator
                               .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                           @"int Sub(int a, int b) {
                                                 return a - b;
                                             }");
             </code>
             </example>
        </member>
        <member name="P:CSScriptLibrary.CSScript.MonoEvaluator">
            <summary>
            Global instance of <see cref="T:CSScriptLibrary.MonoEvaluator"/>. This object is to be used for
            dynamic loading of the  C# code by using Mono "compiler as service".
            <para>If you need to use multiple instances of th evaluator then you will need to call 
            <see cref="T:CSScriptLibrary.IEvaluator"/>.Clone().</para>
            <para>For the majority of the CS-Script script engine hosting scenarios the Mono compiler
            is a preferred runtime. The major advantage is the compilation speed and superior (comparing to CodeDOM)
            memory management.</para>
            </summary>
            <value>The <see cref="T:CSScriptLibrary.MonoEvaluator"/> instance.</value>
        </member>
        <member name="M:CSScriptLibrary.CSScript.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptName(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script) and returns full path of the script file
            used to compile the assembly. The analysis is based on the fact that script assembly (in hosing scenarios) is always
            stamped with <see cref="T:System.Reflection.AssemblyDescriptionAttribute"/>, which contains name of the script file the
            assembly was compiled from.
            <para>The format of the description </para>
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	Script file path if the specified assembly is a script assembly otherwise <c>null</c>.
            </returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.Rethrow">
            <summary>
            Force caught exceptions to be re-thrown.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.AggregateReferencedAssemblies(CSScriptLibrary.ScriptParser,System.String[],System.String)">
            <summary>
            Aggregates the referenced assemblies found by parser.
            </summary>
            <param name="parser">The parser.</param>
            <param name="searchDirs">Extra search/probing directories.</param>
            <param name="defaultRefAssemblies">The default reference assemblies. It is a semicolon separated assembly names string 
            (e.g. "System.Core; System.Linq;").</param>
            <returns></returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.AssemblyResolvingEnabled">
             <summary>
             Enables automatic resolving of unsuccessful assembly probing on the base of the Settings.SearchDirs.
             Default value is true.
            
             CLR does assembly probing only in GAC and in the local (with respect to the application) directories. CS-Script
             however allows you to specify extra directory(es) for assembly probing by setting enabling CS-Script assembly resolving
             through setting the AssemblyResolvingEnabled to true and changing the Settings.SearchDirs appropriately.
             </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ShareHostRefAssemblies">
             <summary>
             Gets or sets the assembly sharing mode. If set to true all assemblies (including the host assembly itself)
             currently loaded to the host application AppDomain are automatically available/accessible from the script code.
             Default value is true.
            
             Sharing the same assembly set between the host application and the script require AssemblyResolvingEnabled to
             be enabled. Whenever SharesHostRefAssemblies is changed to true it automatically sets AssemblyResolvingEnabled to
             true as well.
             </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.GlobalSettings">
            <summary>
            Settings object containing runtime settings, which controls script compilation/execution.
            This is Settings class essentially is a deserialized content of the CS-Script configuration file (css_config.xml).
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CompilingHistory">
            <summary>
            Collection of all compiling results. Every time the script is compiled the compiling result is added to this collection regardless of
            the success or failure of the actual compilation.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.KeepCompilingHistory">
            <summary>
            Gets or sets a value indicating whether compiling history should be kept. The compilation results are stored in <see cref="F:CSScriptLibrary.CSScript.CompilingHistory"></see>.
            </summary>
            <value>
            <c>true</c> if compiling history should be kept; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[])">
            <summary>
            Invokes global (static) CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[],System.Boolean)">
            <summary>
            Invokes CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
            <param name="rethrow">Flag, which indicated if script exceptions should be rethrowed by the script engine without any handling.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempDir">
            <summary>
            Returns the name of the CSScript temporary folder.
            </summary>
            <returns>Temporary folder name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileFiles(System.String[],System.String,System.Boolean,System.String[])">
            <summary>
            Compiles multiple C# files into a single assembly with CSExecutor
            </summary>
            <param name="sourceFiles">Collection of the files to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileFiles(System.String[],System.String[])">
            <summary>
            Compiles multiple C# files into a single assembly with CSExecutor
            </summary>
            <param name="sourceFiles">Collection of the files to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileFile(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor.
            This method is an equivalent of the CSScript.Compile(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileFile(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor.
            This method is an equivalent of the CSScript.Compile(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler. </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateCompilerLock(System.String,System.Boolean)">
            <summary>
            Creates the compiler lock object (<see cref="T:System.Threading.Mutex"/>). The Mutex object is now initially owned.
            <para>This object is to be used for the access synchronization to the compiled script file and it can be useful for the 
            tasks like cache purging or explicit script recompilation.</para>
            <para>The optimisticConcurrencyModel has the same meaning as <see cref="P:csscript.Settings.OptimisticConcurrencyModel"/>. 
            And it is to be used to control the concurrency scope.</para>
            </summary>
            <param name="compiledScriptFile">The script file.</param>
            <param name="optimisticConcurrencyModel">if set to <c>true</c> the operation is thread-safe within the current process. 
            Otherwise the operation is thread-safe system wide..</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,csscript.Settings,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses script engine settings object and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="scriptSettings">The script engine Settings object.</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler.  </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String[])">
             <summary>
             Surrounds the method implementation code into a class and compiles it code into assembly with CSExecutor and loads it in current AppDomain.
             The most convenient way of using dynamic methods is to declare them as static methods. In this case they can be invoked with wild card character 
             as a class name (e.g. asmHelper.Invoke("*.SayHello")). Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
             You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the beginning of the code:
            
             CSScript.LoadMethod(
                 @"using System.Windows.Forms;
            
                 public static void SayHello(string greeting)
                 {
                     MessageBoxSayHello(greeting);
                     ConsoleSayHello(greeting);
                 }
                 public static void MessageBoxSayHello(string greeting)
                 {
                     MessageBox.Show(greeting);
                 }
                 public static void ConsoleSayHello(string greeting)
                 {
                     Console.WriteLine(greeting);
                 }");
             </summary>
             <param name="methodCode">The C# code, containing method implementation.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadDelegate``1(System.String,System.String,System.Boolean,System.String[])">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                     @"int Product(int a, int b)
                                       {
                                           return a * b;
                                       }");
            
             int result = Product(3, 2);
             </code>
             </example>
             <param name="methodCode">The C# code.</param>
             <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
             <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateAction(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
            <para>Returns instance of <see cref="T:CSScriptLibrary.MethodDelegate"/> for the first method in the auto-generated class.</para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            var SayHello = CSScript.CreateAction(@"void SayHello(string greeting)
                                                   {
                                                       Console.WriteLine(greeting);
                                                   }");
            SayHello("Hello World!");
            </code>
            </example>
            <param name="methodCode">The C# code.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Instance of <see cref="T:CSScriptLibrary.MethodDelegate"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateFunc``1(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
            <para>Returns instance of <see cref="T:CSScriptLibrary.MethodDelegate"/> for the first method in the auto-generated class.</para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            var product = CSScript.CreateFunc&lt;intgt;(@"int Product(int a, int b)
                                                     {
                                                         return a * b;
                                                     }");
            int result = product(3, 4);
            </code>
            </example>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="methodCode">The C# code.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Instance of <see cref="T:CSScriptLibrary.MethodDelegate"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                     @"int Product(int a, int b)
                                       {
                                           return a * b;
                                       }");
            
             int result = Product(3, 2);
             </code>
             </example>
             <param name="methodCode">The C# code.</param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateAction(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
            <para>Returns instance of <see cref="T:CSScriptLibrary.MethodDelegate"/> for the first method in the auto-generated class.</para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            var SayHello = CSScript.CreateAction(@"void SayHello(string greeting)
                                                   {
                                                       Console.WriteLine(greeting);
                                                   }");
            SayHello("Hello World!");
            </code>
            </example>
            <param name="methodCode">The C# code.</param>
            <returns>Instance of <see cref="T:CSScriptLibrary.MethodDelegate"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.StopVBCSCompilers">
            <summary>
            Stop any running instances of the compiler server if any. 
            <para>
            Stopping is needed in order to prevent any problems with copying/moving CS-Script binary files (e.g. Roslyn compilers). 
            Servers restart automatically on any attempt to compile any C#/VB.NET code by any client (e.g. Visual Studio, MSBuild, CS-Script).
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateFunc``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
            <para>Returns instance of <see cref="T:CSScriptLibrary.MethodDelegate"/> for the first method in the auto-generated class.</para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            var product = CSScript.CreateFunc&lt;intgt;(@"int Product(int a, int b)
                                                     {
                                                         return a * b;
                                                     }");
            int result = product(3, 4);
            </code>
            </example>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="methodCode">The C# code.</param>
            <returns>Instance of <see cref="T:CSScriptLibrary.MethodDelegate"/>.</returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.EvalNamespaces">
             <summary>
             Sets the <c>;</c>-delimited string containing namespaces to be used by the C# expressions being compiled with
             <see cref="M:CSScriptLibrary.CSScript.Eval"/>.
             <para>The default value is <c>"System;System.IO;System.Diagnostics;System.Collections.Generic;System.Threading"</c></para>
             </summary>
             <para>The following is a typical example of <c>BuildEval</c> usage:</para>
             <code>
             CSScript.EvalNamespaces = "System;System.Diagnostics";
            
             var Trace = CSScript.BuildEval(@"trace (object message)
                                              {
                                                  Trace.WriteLine(""EVAL:"" + message);
                                              }");
            
             var Average = CSScript.BuildEval("avrg (int a, int b)  { return (a+b)/2.0; }");
            
             Trace(Average(7, 8));
             </code>
             <value>
             The <c>Eval</c> namespaces.
             </value>
        </member>
        <member name="M:CSScriptLibrary.CSScript.BuildEval(System.String)">
             <summary>
             Evaluates string as a method code and returns the <see cref="T:CSScriptLibrary.MethodDelegate"/>.
             <para><c>BuildEval</c> is a specific case of <see cref="M:CSScriptLibrary.CSScript.LoadMethod"/>, which
             offers a simpler and more convenient syntactical model. It has number of limitations comparing to
             the <see cref="M:CSScriptLibrary.CSScript.LoadMethod"/>.
             <list type="bullet">
                     <item ><description><c>methodCode</c> should contain nothing else but only a single method definition</description></item>
                     <item ><description>The method signature should not contain any return type.</description></item>
                     <item ><description>All namespaces used by the method code should be either specified explicitly in code or listed in the value of <see cref="P:CSScriptLibrary.CSScript.EvalNamespaces"/>.</description></item>
                     <item ><description>The method code can only interact with the types of the currently loaded in the <c>AppDomain.CurrentDomain</c> assemblies.</description></item>
             </list>
             This is the when the flexibility is partially sacrificed for the sake of convenience.
             <para>The following is a typical example of <c>BuildEval</c> usage:</para>
             <code>
             CSScript.EvalNamespaces = "System;System.Diagnostics";
            
             var Trace = CSScript.BuildEval(@"trace (object message)
                                              {
                                                  Trace.WriteLine(""EVAL:"" + message);
                                              }");
            
             var Average = CSScript.BuildEval("avrg (int a, int b)  { return (a+b)/2.0; }");
            
             Trace(Average(7, 8));
             </code>
             <remarks>Note that CS-Script <c>BuildEval</c> should not be treated as <c>eval</c> in dynamic languages even despite some resemblance. After all C# is a static language.
             <para>CS-Script <c>BuildEval</c> yields the method delegate, which can access all public types of the AppDomain but it cannot interact with the types instances unless
             they are directly passed to the delegate or can be accessed through the Type static members.</para>
             </remarks>
             </para>
             </summary>
             <param name="methodCode">The method code.</param>
             <returns>Delegate with the "evaluated" routine. It can be invoked as any .NET delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Eval(System.Object[])">
             <summary>
             Evaluates string as a method code and executes it with the specified method parameters.
             <para>
             <c>Eval</c> is very similar to <see cref="M:CSScriptLibrary.CSScript.BuildEval(System.String)"/> and it shares the some of its limitations.
             <list type="bullet">
                 <item ><description><c>methodCode</c> should contain nothing else but only a single method definition</description></item>
                 <item ><description>The method signature should not contain any return type.</description></item>
                 <item ><description>All namespaces used by the method code should be either specified explicitly in code or listed in the value of <see cref="P:CSScriptLibrary.CSScript.EvalNamespaces"/>.</description></item>
             </list>
             However <c>Eval</c> offers an important advantage comparing to the <c>BuildEval</c> - after the execution it unloads all dynamically emitted routines
             preventing any potential memory leaks. Though because of this the "evaluated" routines are not reusable thus you need to do the full eval every time
             you wan to invoke the routine. And of course this can affect performance dramatically and that is why usage of <c>Eval</c> should be considered very carefully.
            
             <para>Note that the calling convention is that all parameters of the method to be "evaluated" must be
             followed by the string of code defining this method. </para>
             <para>The following is a typical example of <c>Eval</c> usage:</para>
             <code>
            
             var result = CSScript.Eval(1, 3,
                                      @"sum (int a, int b) {
                                            return a+b;
                                        }");
            
             </code>
            
             <remarks>Note that CS-Script <c>Eval</c> should not be treated as <c>eval</c> in dynamic languages even despite some resemblance.
             After all C# is a static language.
             <para>CS-Script <c>Eval</c> can access all public types of the AppDomain but it cannot interact with the types instances unless
             they are directly passed to the delegate or can be accessed through the Type static members.</para>
             </remarks>
            
            
             </para>
             </summary>
             <param name="args">Collection of the method parameters followed by the method code.</param>
             <returns>The return value of the method being "evaluated"</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String,System.Boolean,System.String[])">
             <summary>
             Surrounds the method implementation code into a class and compiles it code into
             assembly with CSExecutor and loads it in current AppDomain. The most convenient way of
             using dynamic methods is to declare them as static methods. In this case they can be
             invoked with wild card character as a class name (e.g. asmHelper.Invoke("*.SayHello")).
             Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
            
             You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the beginning of the code:
             <code>
             CSScript.LoadMethod(
                 @"using System.Windows.Forms;
            
                 public static void SayHello(string greeting)
                 {
                     MessageBoxSayHello(greeting);
                     ConsoleSayHello(greeting);
                 }
                 public static void MessageBoxSayHello(string greeting)
                 {
                     MessageBox.Show(greeting);
                 }
                 public static void ConsoleSayHello(string greeting)
                 {
                     Console.WriteLine(greeting);
                 }");
             </code>
             </summary>
             <param name="methodCode">The C# code, containing method implementation.</param>
             <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
             <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="scriptFile">The script file.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadFiles(System.String[],System.String,System.Boolean,System.String[])">
            <summary>
            Compiles code from the specified files into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="sourceFiles">The source files to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadFiles(System.String[],System.String[])">
            <summary>
            Compiles code from the specified files into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="sourceFiles">The source files to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="scriptFile">The script file.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            <param name="scriptFile">The script file.</param>
            <param name="tempFileExtension">The file extension of the temporary file to hold script code during compilation. This parameter may be
            needed if custom CS-Script compilers rely on file extension to identify the script syntax.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="tempFileExtension">The file extension of the temporary file to hold script code during compilation. This parameter may be
            needed if custom CS-Script compilers rely on file extension to identify the script syntax.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor and loads it in current AppDomain
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadWithConfig(System.String,System.String,System.Boolean,csscript.Settings,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor and loads it in current AppDomain
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="scriptSettings">The script engine Settings object. You can pass null to load <c>CSScript.GlobalSettings</c>. </param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler.  </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String)">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.DefaultPrint(System.String)">
            <summary>
            Default implementation of displaying application messages.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CSScript.LoadedScript">
            <summary>
            LoadedScript is a class, which holds information about the script file location and it's compiled and loaded assmbly (current AppDomain).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadedScript.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Creates instance of LoadedScript
            </summary>
            <param name="script">Script file location.</param>
            <param name="asm">Compiled script assembly loaded into current AppDomain.</param>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.script">
            <summary>
            Script file location.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.asm">
            <summary>
            Compiled script assembly loaded into current AppDomain.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CacheEnabled">
            <summary>
            Controls if ScriptCache should be used when script file loading is requested (CSScript.Load(...)). If set to true and the script file was previously compiled and already loaded
            the script engine will use that compiled script from the cache instead of compiling it again.
            Note the script cache is always maintained by the script engine. The CacheEnabled property only indicates if the cached script should be used or not when CSScript.Load(...) method is called.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ResolveSourceAlgorithm">
            <summary>
            The resolve source file algorithm.
            <para>
            The default algorithm searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_DIR%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            </para>
            <para>If the default implementation isn't suitable then you can set <c>CSScript.ResolveSourceAlgorithm</c> 
            to the alternative implementation of the probing algorithm.</para>
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ResolveAssemblyAlgorithm">
            <summary>
            Resolves namespace/assembly(file) name into array of assembly locations (local and GAC ones).
            </summary>
            <para>If the default implementation isn't suitable then you can set <c>CSScript.ResolveAssemblyAlgorithm</c> 
            to the alternative implementation of the probing algorithm.</para>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ScriptCache">
            <summary>
            Cache of all loaded script files for the current process.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetCachedScriptAssemblyFile(System.String)">
            <summary>
            Returns file path of the cached script assembly matching the script file name.
            </summary>
            <param name="file">Script file path.</param>
            <returns>Path to the previously compiled script assembly.
            Returns null if the cached script cannot be found.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetLoadedCachedScriptAssembly(System.String)">
            <summary>
            Returns loaded cached script assembly matching the script file name.
            </summary>
            <param name="file">Script file path.</param>
            <returns>Assembly loaded in the current AppDomain.
            Returns null if the loaded script cannot be found.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetCachedScriptPath(System.String)">
            <summary>
            Returns path to the cached script assembly matching the script file name.
            </summary>
            <param name="scriptFile">Script file path.</param>
            <returns>Cached (compiled) script assembly file path.</returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.IsOutOfDateAlgorithm">
            <summary>
            Compiled script probing handler. Analyses the script file and the compiled script (script assembly)
            and determines if the script assembly is out of data and needs to be recompiled.
            <para>The default implementation is <see cref="P:CSScriptLibrary.CSScript.CachProbing.Simplified"/>.</para>
            <para>You can always supply your custom algorithm. For example <p>
            <c>CSScript.IsOutOfDateAlgorithm = (s, a) => true;</c></p>
            fill force CS-Script to recompile the script every time it is loaded.</para>
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.IsOutOfDate">
            <summary>
            Compiled script probing handler. Analyses the script file and the compiled script (script assembly)
            and determines if the script assembly is out of data and needs to be recompiled.
            <para>The default implementation is <see cref="P:CSScriptLibrary.CSScript.CachProbing.Simplified"/>.</para>
            <para>You can always supply your custom algorithm. For example <p>
            <c>CSScript.IsOutOfDate = (s, a) => true;</c></p>
            will force CS-Script to recompile the script every time it is loaded.</para>
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CSScript.CachProbing">
            <summary>
            This class contains default implementations of the <see cref="P:CSScriptLibrary.CSScript.IsOutOfDateAlgorithm"/>.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.CachProbing.Simplified">
            <summary>
            Gets the simplified IsOutOfDateAlgorithm implementation. The implementation is based on analysis of the 'LastWriteTimeUtc' timestamps of the script and compiled script assembly. But not the script dependencies.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.CachProbing.Advanced">
            <summary>
            Gets the comprehensive IsOutOfDateAlgorithm implementation. The implementation is based on analysis of the 'LastWriteTimeUtc' timestamps of the script, compiled script assembly and all script dependencies.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CodeDomEvaluator">
            <summary>
            A wrapper class that encapsulates the functionality of the Roslyn  evaluator (<see cref="N:Microsoft.CodeAnalysis.CSharp.Scripting"/>).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.CodeDomEvaluator" /> class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.Clone(System.Boolean)">
            <summary>
            Clones itself as <see cref="T:CSScriptLibrary.IEvaluator"/>. 
            <para>
            This method returns a freshly initialized copy of the <see cref="T:CSScriptLibrary.IEvaluator"/>. 
            The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies"/>.
            </para>
            <para>   
            This method is a convenient technique when multiple <see cref="T:CSScriptLibrary.IEvaluator"/> instances  
            are required (e.g. for concurrent script evaluation).
            </para>
            </summary>
            <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLibrary.IEvaluator"/> 
            will be referenced in the cloned copy.</param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="P:CSScriptLibrary.CodeDomEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, currently only CodeDom fully supports generation of debugging symbols.</para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.CompileCode(System.String)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s). 
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.CodeDomEvaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");
                                                      
             dynamic script =  asm.CreateObject("*"); 
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="P:CSScriptLibrary.CodeDomEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies 
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)"/> but is allows you to define 
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.CodeDomEvaluator
                                      .CompileMethod(@"int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }")
                                      .CreateObject("*"); 
                                      
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.CodeDomEvaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");
            
             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.CodeDomEvaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/></returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.GetReferencedAssemblies">
            <summary>
            Loads and returns set of referenced assemblies. 
            <para>
            Notre: the set of assemblies is cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Analyses the script code and returns set of locations for the assemblies referenced from the code with CS-Script directives (//css_ref).
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.CodeDomEvaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadCode``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> Because the interface alignment is a duck typing implementation the script class doesn't have to 
             inherit from <c>T</c>.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.CodeDomEvaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadDelegate``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
            </summary>
             <example>
            <code>
            var Product = CSScript.CodeDomEvaluator
                                  .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                              @"int Product(int a, int b)
                                                {
                                                    return a * b;
                                                }");
                                           
            int result = Product(3, 2);
            </code>
            </example>
            <param name="code">The C# code.</param>
            <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadFile(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.CodeDomEvaluator
                                      .LoadFile("calc.cs");
                                      
             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadFile``1(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.CodeDomEvaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");
                                  
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
             the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.CodeDomEvaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");
            
             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.CodeDomEvaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the 
            optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.CodeDomEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating evaluation infrastructure (e.g. compiler setting)
            and reconnection to or recreation of the underlying compiling services. 
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with 
            <paramref name="referenceDomainAssemblies"/>.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLibrary.CodeDomEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)"/> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="T:CSScriptLibrary.CSScriptRoslynExtensions">
            <summary>
            Method extensions for Roslyn.<see cref="N:Microsoft.CodeAnalysis.CSharp.Scripting"/>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScriptRoslynExtensions.Load(System.String)">
            <summary>
            Single step evaluating method for Roslyn compiler. Compiles specified code, loads the compiled assembly and returns it to the caller.
            </summary>
            <param name="code">The code.</param>
            <returns></returns>
        </member>
        <member name="T:CSScriptLibrary.RoslynEvaluator">
            <summary>
            A wrapper class that encapsulates the functionality of the Roslyn  evaluator (<see cref="N:Microsoft.CodeAnalysis.CSharp.Scripting"/>).
            </summary>
        </member>
        <member name="P:CSScriptLibrary.RoslynEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, affect of setting <c>DebugBuild</c> will always depend on the compiler implementation:
            <list type="bullet">
               <item><term>CodeDom</term><description>Fully supports. Generates degugging symbols (script can be debugged) and defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Mono</term><description>Partially supports. Defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Roslyn</term><description>Doesn't supports at all.</description> </item>
            </list>
            </para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.RoslynEvaluator" /> class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.Clone(System.Boolean)">
            <summary>
            Clones itself as <see cref="T:CSScriptLibrary.IEvaluator"/>. 
            <para>
            This method returns a freshly initialized copy of the <see cref="T:CSScriptLibrary.IEvaluator"/>. 
            The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies"/>.
            </para>
            <para>
            This method is a convenient technique when multiple <see cref="T:CSScriptLibrary.IEvaluator"/> instances  
            are required (e.g. for concurrent script evaluation).
            </para>
            </summary>
            <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLibrary.IEvaluator"/> 
            will be referenced in the cloned copy.</param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="P:CSScriptLibrary.RoslynEvaluator.CompilerSettings">
            <summary>
            Gets or sets the compiler settings.
            </summary>
            <value>The compiler settings.</value>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadCompilers">
            <summary>
            Loads the assemblies implementing Roslyn compilers.
            <para>Roslyn compilers are extremely heavy and loading the compiler assemblies for with the first 
            evaluation call can take a significant time to complete (in some cases up to 4 seconds) while the consequent 
            calls are very fast. 
            </para>
            <para>
            You may want to call this method to pre-load the compiler assembly your script evaluation performance.
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.CompileCode(System.String)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s). 
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.RoslynEvaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");
                                                      
             dynamic script =  asm.CreateObject("*"); 
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)"/> but is allows you to define 
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .CompileMethod(@"int Sum(int a, int b)
                                                          {
                                                           return a+b;
                                                       }")
                                      .CreateObject("*"); 
                                      
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.RoslynEvaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");
            
             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.RoslynEvaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/></returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.GetReferencedAssemblies">
            <summary>
            Returns set of referenced assemblies. 
            <para>
            Notre: the set of assemblies is cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Analyses the script code and returns set of locations for the assemblies referenced from the code with CS-Script directives (//css_ref).
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadCode``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> Because the interface alignment is a duck typing implementation the script class doesn't have to 
             inherit from <c>T</c>.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.RoslynEvaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadDelegate``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
            </summary>
             <example>
            <code>
            var Product = CSScript.RoslynEvaluator
                                  .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                              @"int Product(int a, int b)
                                                {
                                                    return a * b;
                                                }");
                                           
            int result = Product(3, 2);
            </code>
            </example>
            <param name="code">The C# code.</param>
            <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadFile(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadFile("calc.cs");
                                      
             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadFile``1(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");
                                  
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
             the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");
            
             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.RoslynEvaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="P:CSScriptLibrary.RoslynEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies 
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the 
            optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.RoslynEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating evaluation infrastructure (e.g. compiler setting)
            and reconnection to or recreation of the underlying compiling services. 
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with 
            <paramref name="referenceDomainAssemblies"/>.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLibrary.RoslynEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)"/> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="T:CSScriptLibrary.IRemoteAgent">
            <summary>
            <para> Do not use as this interface as it's intended for use by CS-Script engine only. </para>
            Interface that is used by CS-Script engine to build transparent proxies for EvaluatorRemoting extensions.
            This interface has to be public as it is passed across assemblies. 
            </summary>
        </member>
        <member name="T:CSScriptLibrary.AttachedProperies">
            <summary>
            The extremely simple implementation of generic "Extension Properties".
            Originally published on CodeProject: http://www.codeproject.com/Articles/399932/Extension-Properties-Revised
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AttachedProperies.SetValue``1(``0,System.String,System.Object)">
            <summary>
            Sets the named value to the object.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="obj">The object.</param>
            <param name="name">The name of the value.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.AttachedProperies.GetValue``1(System.Object,System.String)">
            <summary>
            Gets the named value of the object.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="obj">The object.</param>
            <param name="name">The name of the value.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.AttachedProperies.GetValue(System.Object,System.String)">
            <summary>
            Gets the named value of the object.
            </summary>
            <param name="obj">The object.</param>
            <param name="name">The name of the value.</param>
            <returns></returns>
        </member>
        <member name="T:CSScriptLibrary.EvaluatorRemoting">
            <summary>
            Extension methods for invocation of <see cref="T:CSScriptLibrary.IEvaluator"/> methods in a remote AppDomain. 
            </summary>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.GetRemoteDomain(CSScriptLibrary.IEvaluator)">
            <summary>
            Gets the remote AppDomain associated with the evaluator. 
            The AppDomain is set to the Evaluator with the last call of 
            any EvaluatorRemoting extension methods. 
            </summary>
            <param name="evaluator">The evaluator.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.GetOwnerObject``1(System.Object)">
            <summary>
            Gets the owner/parent of the object. This method is used to access the
            remote object owning the MethodDelegate returned to the caller AppDomain
            with the EvaluatorRemoting extension methods.
            </summary>
            <typeparam name="T">The type of the .</typeparam>
            <param name="obj">The object.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.GetOwnerDomain(System.Object)">
            <summary>
            Gets the AppDomain owning the actual object the transparent proxy is associated with.
            The AppDomain is set to the proxy object on any EvaluatorRemoting extension methods call. 
            </summary>
            <param name="obj">The transparent proxy object.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.UnloadOwnerDomain(System.Object)">
            <summary>
            Unloads the AppDomain owning the actual object the transparent proxy is associated with.
            </summary>
            <param name="obj">The transparent proxy object.</param>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.LoadMethodRemotely``1(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Loads the method remotely.
             LoadMethodRemotely is essentially the same as <see cref="M:CSScriptLibrary.EvaluatorRemoting.LoadCodeRemotely``1(CSScriptLibrary.IEvaluator,System.String,System.String[])"/>. 
             It just deals not with the whole class definition but a method(s) only. And the rest of the class definition is 
             added automatically by CS-Script. 
             </summary>
             <example>
            <code>
             var script = CSScript.Evaluator
                                  .LoadMethodRemotely&lt;ICalc&gt;(
                                                     @"public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                       public int Sub(int a, int b)
                                                       {
                                                           return a-b;
                                                       }");
             
             int result = script.Sum(15, 3));
             
             // after the next line call the remote domain with loaded script will be unloaded
             script.UnloadOwnerDomain();
             </code>
             </example>
             <typeparam name="T">The type of the T.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.LoadFileRemotely``1(CSScriptLibrary.IEvaluator,System.String)">
            <summary>
            Loads the script file remotely.
            <para>This method is essentially identical to <see cref="M:CSScriptLibrary.EvaluatorRemoting.LoadCodeRemotely{T}"/>.
            Except it loads the code not from the in-memory string but from the file.</para>
            </summary>
            <typeparam name="T">The interface type the remote object should be casted or aligned (duck-typed) to.</typeparam>
            <param name="evaluator">The evaluator.</param>
            <param name="scriptFile">The script file.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.LoadCodeRemotely``1(CSScriptLibrary.IEvaluator,System.String,System.String[])">
             <summary>
             Loads/evaluates C# code into a remote AppDomain and returns a transparent proxy of the 
             instance of the first class defined in the code.
             <para>The returned proxy can be used to unload the AppDomain owning the actual object 
             the proxy points to.</para>
             </summary>
             <remarks>
             Note, the concrete type of the return value depends on the script class definition. 
             It the class implement interface then an ordinary type castes proxy object is returned. 
             However if the class doesn't implement the interface the a dynamically emitted duck-typed
             proxy returned instead. Such proxy cannot be built for the types implemented in file-less 
             (in-memory) assemblies. Thus neither Mono nor Roslyn engines cannot be used with this 
             technique. Meaning that 
             <see cref="P:CSScriptLibrary.CSScript.CodeDomEvaluator"/> needs to be used.
             <para>While the script class to be evaluated doesn't have to implement from 'T' interface but 
             it must inherit <see cref="T:System.MarshalByRefObject"/> though.</para>
             </remarks>
             <example>
            <code>
             // duck-typed proxy; must use CodeDomEvaluator                       
             var script = CSScript.CodeDomEvaluator
                                  .LoadCodeRemotely&lt;ICalc&gt;(
                                  @"using System;
                                    public class Calc : MarshalByRefObject
                                    {
                                        public int Sum(int a, int b)
                                        {
                                            return a + b;
                                        }
                                    }");
                                    
             // ordinary type casted proxy                       
             var script2 = CSScript.Evaluator
                                   .LoadCodeRemotely&lt;ICalc&gt;(
                                   @"using System;
                                     public class Calc : MarshalByRefObject : ICalc
                                     {
                                         public int Sum(int a, int b)
                                         {
                                             return a + b;
                                         }
                                     }");
                                     
             int result = script.Sum(15, 3);
              
             // after the next line call the remote domain with loaded script will be unloaded
             script.UnloadOwnerDomain();
             </code>
             </example>
             <typeparam name="T">The interface type the remote object should be casted or aligned (duck-typed) to.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptCode">The script code that defines the script class to be loaded.  
             <para>The script class doesn't have to implement from 'T' interface but 
             it must inherit <see cref="T:System.MarshalByRefObject"/> though.</para>
             </param>
             <param name="probingDirs">The probing directories for the assemblies the script 
             assembly depends on.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.CreateDelegateRemotely(CSScriptLibrary.IEvaluator,System.String,System.String[])">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), 
             evaluates it and loads the class to the remote AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/> of the remote object for 
             class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             
             var log = CSScript.Evaluator
                               .CreateDelegateRemotely(
                                               @"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");
            
             log("Test message");
            
             log.UnloadOwnerDomain();
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The C# code.</param>
             <param name="probingDirs">The probing directories for the assemblies the script 
             assembly depends on.</param>
             <returns> The instance of a 'duck typed' <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorRemoting.CreateDelegateRemotely``1(CSScriptLibrary.IEvaluator,System.String,System.String[])">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) implementing interface T, 
             evaluates it and loads the class to the remote AppDomain.
             <para>Returns typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.Evaluator
                                   .CreateDelegateRemotely&lt;int&gt;(
                                                       @"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
             int result = product(3, 2);
            
             product.UnloadOwnerDomain();
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The C# code.</param>
             <param name="probingDirs">The probing directories for the assemblies the script 
             assembly depends on.</param>
             <returns> The instance of a 'duck typed' <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="T:CSScriptLibrary.EvaluatorAsync">
            <summary>
            Extension methods for asynchronous invocation of <see cref="T:CSScriptLibrary.IEvaluator"/> methods 
            with Async and Await available in C# 5. 
            </summary>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.CompileCodeAsync(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 Assembly script = await CSScript.Evaluator
                                                 .CompileCodeAsync(
                                                              @"using System;
                                                                public class Calc
                                                                {
                                                                    public int Sum(int a, int b)
                                                                    {
                                                                        return a+b;
                                                                    }
                                                                }");
                 dynamic calc = script.CreateObject("*");
            
                 textBox1.Text = calc.Sum(3, 2).ToString();
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptText">The C# code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.CompileMethodAsync(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.CompileMethod(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                  Assembly script = await CSScript.Evaluator
                                                  .CompileMethodAsync(
                                                               @"int Sum(int a, int b)
                                                                 {
                                                                     return a+b;
                                                                 }");
                  dynamic calc = script.CreateObject("*");
                  
                  textBox1.Text = calc.Sum(3, 7).ToString();
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.CreateDelegateAsync``1(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.CreateDelegate``1(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 var product = await CSScript.Evaluator
                                             .CreateDelegateAsync&lt;int&gt;(
                                                       @"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
                 textBox1.Text = product(3, 2).ToString();        
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The C# script text.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.CreateDelegateAsync(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.CreateDelegate(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 var log = await CSScript.Evaluator
                                         .CreateDelegateAsync(
                                             @"void Log(string message)
                                               {
                                                   Console.WriteLine(message);
                                               }");
            
                 log("Test message");
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The C# script text.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadCodeAsync(CSScriptLibrary.IEvaluator,System.String,System.Object[])">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadCode(System.String,System.Object[])"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 dynamic calc = await CSScript.Evaluator
                                              .LoadCodeAsync(
                                                       @"using System;
                                                         public class Script
                                                         {
                                                             public int Sum(int a, int b)
                                                             {
                                                                 return a+b;
                                                             }
                                                         }");
                                                         
                 textBox1.Text = calc.Sum(1, 2).ToString();
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadCodeAsync``1(CSScriptLibrary.IEvaluator,System.String,System.Object[])">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadCode``1(System.String,System.Object[])"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 ICalc calc = await CSScript.Evaluator
                                            .LoadCodeAsync&lt;ICalc&gt;(
                                                       @"using System;
                                                         public class Script
                                                         {
                                                             public int Sum(int a, int b)
                                                             {
                                                                 return a+b;
                                                             }
                                                         }");
                 textBox1.Text = calc.Sum(1, 2).ToString();
             }
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadFileAsync``1(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadFile``1(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 ICalc script = await CSScript.Evaluator
                                              .LoadFileAsync&lt;ICalc&gt;("calc.cs");
            
                 textBox1.Text = script.Sum(1, 2).ToString();
             }
             </code>
             </example>
             <typeparam name="T">The type of the T.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptFile">The C# script file.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadFileAsync(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadFile(System.String)"/>.
             </summary>
             <example>
            <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 dynamic script = await CSScript.Evaluator
                                                .LoadFileAsync("calc.cs");
            
                 textBox1.Text = script.Sum(1, 2).ToString();
             }
             </code>
             </example>
             <param name="evaluator">The evaluator.</param>
             <param name="scriptFile">The C# script file.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadMethodAsync(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadMethod(System.String)"/>.
             </summary>
             <example><code>
             async void button1_Click(object sender, EventArgs e)
             {
                 ICalc script = await CSScript.Evaluator
                                              .LoadMethodAsync&lt;ICalc&gt;(
                                                   @"public int Sum(int a, int b)
                                                     {
                                                         return a + b;
                                                     }
                                                     public int Div(int a, int b)
                                                     {
                                                         return a/b;
                                                     }");
            
                textBox1.Text = script.Div(15, 3).ToString();
            }
             </code></example>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadMethodAsync``1(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadMethod``1(System.String)"/>.
             </summary>
             <example><code>
             async void button1_Click(object sender, EventArgs e)
             {
                 ICalc script = await CSScript.Evaluator
                                              .LoadMethodAsync&lt;ICalc&gt;(
                                                  @"public int Sum(int a, int b)
                                                    {
                                                        return a + b;
                                                    }
                                                    public int Div(int a, int b)
                                                    {
                                                        return a/b;
                                                    }");
            
                textBox1.Text = script.Div(15, 3).ToString();
            }
             </code></example>
             <typeparam name="T">The type of the T.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.EvaluatorAsync.LoadDelegateAsync``1(CSScriptLibrary.IEvaluator,System.String)">
             <summary>
             Asynchronous version of <see cref="M:CSScriptLibrary.IEvaluator.LoadDelegate``1(System.String)"/>.
             </summary>
             <example>
             <code>
             async void button1_Click(object sender, EventArgs e)
             {
                 var product = await CSScript.Evaluator
                                             .LoadDelegateAsync&lt;Func&lt;int, int, int&gt;&gt;(
                                              @"int Product(int a, int b)
                                                {
                                                    return a * b;
                                                }");
            
                 textBox1.Text = product(3, 2).ToString();
             }
             </code>
             </example>
             <typeparam name="T">The type of the T.</typeparam>
             <param name="evaluator">The evaluator.</param>
             <param name="code">The code.</param>
             <returns></returns>
        </member>
        <member name="T:CSScriptLibrary.DomainAssemblies">
            <summary>
            Type of the assemblies to be loaded/referenced.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.None">
            <summary>
            No assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.AllStatic">
            <summary>
            All static current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.AllStaticNonGAC">
            <summary>
            All static and non-GAC current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.All">
            <summary>
            All current AppDomain assemblies
            </summary>
        </member>
        <member name="T:CSScriptLibrary.EvaluatorEngine">
            <summary>
            Type of the evaluator engine. 
            <para>This enum is used to control type of compiler the generic 
            CSScript.<see cref="P:CSScriptLibrary.CSScript.Evaluator"/> encapsulates.</para>
            </summary>
        </member>
        <member name="F:CSScriptLibrary.EvaluatorEngine.Roslyn">
            <summary>
            Roslyn compilation services
            </summary>
        </member>
        <member name="F:CSScriptLibrary.EvaluatorEngine.Mono">
            <summary>
            Mono compilation services
            </summary>
        </member>
        <member name="F:CSScriptLibrary.EvaluatorEngine.CodeDom">
            <summary>
            CodeDom compilation infrastructure
            </summary>
        </member>
        <member name="T:CSScriptLibrary.EvaluatorAccess">
            <summary>
            Runtime instantiation model for CS-Script evaluators (e.g CSScript.<see cref="P:CSScriptLibrary.CSScript.Evaluator"/>). 
            </summary>
        </member>
        <member name="F:CSScriptLibrary.EvaluatorAccess.Singleton">
            <summary>
            Every time the member variable is accessed the same static object is returned.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.EvaluatorAccess.AlwaysCreate">
            <summary>
            Every time the member variable is accessed a new object is created.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.EvaluatorConfig">
            <summary>
            Class that contains configuration options for controlling dynamic code evaluation with CSScript.<see cref="P:CSScriptLibrary.CSScript.Evaluator"/>.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.EvaluatorConfig.Access">
            <summary>
            Gets or sets the default access type for CS-Script evaluators.
               <para>This property controls the how the generic 
            CS-Script evaluators are instantiated when accessed (e.g.
            CSScript.<see cref="P:CSScriptLibrary.CSScript.Evaluator"/> or ).
            </para>
            </summary>
            <value>The access.</value>
        </member>
        <member name="P:CSScriptLibrary.EvaluatorConfig.DebugBuild">
            <summary>
            Default value of the <see cref="T:CSScriptLibrary.IEvaluator"/>.DebugBuild property controlling the generation of the debug symbols.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.EvaluatorConfig.RefernceDomainAsemblies">
            <summary>
            Flag that controls if the host AppDo,main referenced assemblies are automatically referenced at creation 
            of <see cref="T:CSScriptLibrary.IEvaluator"/>.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.EvaluatorConfig.Engine">
            <summary>
            Gets or sets the default evaluator engine type.
            <para>This property controls the type of compiler the generic 
            CSScript.<see cref="P:CSScriptLibrary.CSScript.Evaluator"/> encapsulates.</para>
            </summary>
            <value>The default evaluator engine.</value>
        </member>
        <member name="T:CSScriptLibrary.IEvaluator">
            <summary>
            A generic interface of the CS-Script evaluator. It encapsulates the generic functionality of the evaluator regardless
            of the nature of the underlying compiling services (e.g. Mono, Roslyn, CodeDom).
            </summary>
        </member>
        <member name="P:CSScriptLibrary.IEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, affect of setting <c>DebugBuild</c> will always depend on the compiler implementation:
            <list type="bullet">
               <item><term>CodeDom</term><description>Fully supports. Generates debugging symbols (script can be debugged) and defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Mono</term><description>Partially supports. Defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Roslyn</term><description>Doesn't supports at all.</description> </item>
            </list>
            </para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CSScriptLibrary.IEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies 
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s). 
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.Evaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");
                                                      
             dynamic script =  asm.CreateObject("*"); 
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)"/> but is allows you to define 
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.Evaluator
                                      .CompileCode(@"int Sum(int a, int b)
                                                     {
                                                         return a+b;
                                                     }")
                                      .CreateObject("*"); 
                                      
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.Evaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");
            
             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a 'duck typed' <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.Evaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/></returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Analyses the script code and returns set of locations for the assemblies referenced from the code with CS-Script directives (//css_ref).
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.GetReferencedAssemblies">
            <summary>
            Returns set of referenced assemblies. 
            <para>
            Notre: the set of assemblies is cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadCode``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> Because the interface alignment is a duck typing implementation the script class doesn't have to 
             inherit from <c>T</c>.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadDelegate``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
            </summary>
             <example>
            <code>
            var Product = CSScript.Evaluator
                                  .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                              @"int Product(int a, int b)
                                                {
                                                    return a * b;
                                                }");
                                           
            int result = Product(3, 2);
            </code>
            </example>
            <param name="code">The C# code.</param>
            <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadFile(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadFile("calc.cs");
                                      
             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadFile``1(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");
                                  
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
             the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.Evaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");
            
             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.Evaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the 
            optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating evaluation infrastructure (e.g. compiler setting)
            and reconnection to or recreation of the underlying compiling services.
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with 
            <paramref name="referenceDomainAssemblies"/>.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLibrary.IEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)"/> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.IEvaluator.Clone(System.Boolean)">
             <summary>
             Clones the parent <see cref="T:CSScriptLibrary.IEvaluator"/>. 
             <para>
             This method returns a freshly initialized copy of the <see cref="T:CSScriptLibrary.IEvaluator"/>. 
             The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies"/>.
             </para>
             <para>
             This method is a convenient technique when multiple <see cref="T:CSScriptLibrary.IEvaluator"/> instances  
             are required (e.g. for concurrent script evaluation).
             </para>
             </summary>
             <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLibrary.IEvaluator"/> 
             will be referenced in the cloned copy.</param>
             <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
             <example>
            <code>
             var eval1 = CSScript.Evaluator.Clone();
             var eval2 = CSScript.Evaluator.Clone();
             
             var sub = eval1.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a - b;
                                          }");
                                          
             var sum = eval2.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a + b;
                                          }");
                                          
             var result = sum(7, sub(4,2));
             </code>
             </example>
        </member>
        <member name="T:CSScriptLibrary.Ref`1">
             <summary>
             This class encapsulates another object for the purpose of passing it to the anonymous methods as parameters.
             <para>This lass helps to overcome the problem when <c>struct</c> or <c>immutable</c> types cannot be passed to the
             anonymous methods with the <c>ref</c> modifier.</para>
             <example>The following is the example of the updating the local variable of a value type from the anonymous method:
            <code>
             var count = new Ref&lt;int&gt;(1);
            
             Action&lt;Ref&lt;int&gt;&gt; increment =
                               arg =>
                               {
                                   arg.Value += 1;
                               };
            
             increment(count);
             </code>
             </example>
             </summary>
             <typeparam name="T">Type of the encapsulated object.</typeparam>
        </member>
        <member name="M:CSScriptLibrary.Ref`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.Ref`1"/> class.
            </summary>
            <param name="value">The object to be encapsulated.</param>
        </member>
        <member name="P:CSScriptLibrary.Ref`1.Value">
            <summary>
            Gets or sets the value of the encapsulated object.
            </summary>
            <value>
            The value.
            </value>
        </member>
        <member name="M:CSScriptLibrary.Ref`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents encapsulated object.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents encapsulated object.
            </returns>
        </member>
        <member name="T:CSScriptLibrary.AppDomainHelper">
            <summary>
            Simple helper class for extending functionality of <see cref="T:System.AppDomain" />.
            <para>
            This class mainly consist of the extension methods for <see cref="T:System.AppDomain" /> and it is to be used for executing the arbitrary
            code routines in the separate (temporary) <see cref="T:System.AppDomain" /> with the optional unloading.
            </para>This class is particularly useful for executing the CS-Script script in the separate <see cref="T:System.AppDomain" /> as this is the
            only way to unload the script assembly after the execution (known .NET limitation).
            <para>
            <example>The following are the examples of the execution CS-Script scripts and unloading them after the execution:
            <code>
            AppDomain.CurrentDomain
                     .Clone()
                     .Execute(Job)
                     .Unload();
            ...
            void Job()
            {
                var script = CSScript.LoadMethod("some C# script code")
                                     .GetStaticMethod();
                script();
            };
            </code>
            <code>
            AppDomain remote = AppDomain.CurrentDomain.Clone();
            remote.Execute(() =&gt;
            {
                var Sum = CSScript.BuildEval(@"func(float a, float b) {
                                                   return a + b;
                                               }");
                var Average = CSScript.BuildEval(@"func(float a, float b) {
                                                       return (a + b)/2;
                                                   }");
                Console.WriteLine("Sum = {0}\nAverage={1}", Sum(1f, 2f), Average(1f, 2f));
            });
            remote.Unload();
            </code>
            </example>
            </para>
            <remarks>
            The functionality of this class is very similar to the <see cref="T:CSScriptLibrary.AsmHelper" />, which also allows executing and unloading the script(s).
            However  <see cref="T:CSScriptLibrary.AppDomainHelper" /> is designed as a generic class and as such it is more suitable for executing a "job" routines instead of individual scripts.
            <para>
            This creates some attractive opportunities for grouping scripting routines in a single <see cref="T:CSScriptLibrary.AsmHelper" />, which allows simple calling conventions (e.g. <c>CSScript.Load()</c>
            instead of <c>CSScript.Compile()</c>) lighter type system (e.g. no need for MarshalByRefObject inheritance).
            </para>
            </remarks>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Execute(System.AppDomain,System.Action,System.String[])">
             <summary>
             Executes the <see cref="T:System.Action"/> delegate in the specified <see cref="T:System.AppDomain"/>.
             <example>The following are the examples of the execution CS-Script scripts and unloading them after the execution:
            <code>
             var remoteDomain = AppDomain.CurrentDomain.Clone();
             remoteDomain.Execute(Job)
             remoteDomain.Unload();
             ...
            
             void Job()
             {
                 var script = CSScript.LoadMethod("some C# script code")
                                      .GetStaticMethod();
                 script();
             }
             </code>
             </example>
             </summary>
             <param name="domain">The <see cref="T:System.AppDomain"/> the delegate should be executed in.</param>
             <param name="action">The delegate.</param>
             <param name="probingDirs">The assembly probing directories of the AppDomain.</param>
             <returns>Reference to the <see cref="T:System.AppDomain"/>. It is the same object, which is passed as the <paramref name="domain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Execute``1(System.AppDomain,System.Action{``0},``0,System.String[])">
             <summary>
             Executes the <see cref="T:System.Action"/> delegate in the specified <see cref="T:System.AppDomain"/>.
             <para>This method is allows you to pass the execution context parameter of the <c>T</c> type. Note <c>T</c> type must be serializable or inherited from
             <c>MarshalByRefObject</c>.</para>
             <para>This technique allows using AppDomain-neutral anonymous methods, which do not directly reference any variables from the primary
             <c>AddDomain</c> and yet allow interacting with this domain through the context parameter.</para>
             <example>The following is the example of the updating the primary AppDomain local variable <c>foo</c> from the routine executed in the remote domain:
            <code>
             var foo = new Ref&lt;string&gt;("foo");
             AppDomain.CurrentDomain
                      .Clone()
                      .Execute(context =&gt;
                               {
                                   context.Value = "FOO";
                               },
                               context:foo)
                      .Unload();
             </code>
             Note that the example is using <see cref="T:CSScriptLibrary.Ref`1"/> type to to allow custom boxing. This is because the anonymous methods do not allow ref/out parameter modifiers.
             </example>
             </summary>
             <typeparam name="T"></typeparam>
             <param name="domain">The <see cref="T:System.AppDomain"/> the delegate should be executed in.</param>
             <param name="action">The delegate.</param>
             <param name="context">The context data. Note the type of this parameter must be either <c>serializable</c> or inherited from <c>MarshalByRefObject </c> .</param>
             <param name="probingDirs">The assembly probing directories of the AppDomain.</param>
             <returns>Reference to the <see cref="T:System.AppDomain"/>. It is the same object, which is passed as the <paramref name="domain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.ExecuteAndUnload(System.Action)">
             <summary>
             <para>Executes the delegate in the temporary <see cref="T:System.AppDomain"/> with the following unloading of this domain.
             </para>
             <example>The following code the complete equivalent implementation of the <c>ExecuteAndUnload</c>:
            <code>
             AppDomain.CurrentDomain
                      .Clone()
                      .Execute(action)
                      .Unload();
             </code>
             </example>
             </summary>
             <param name="action">The delegate to be executed.</param>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Unload(System.AppDomain)">
            <summary>
            Unloads the specified <see cref="T:System.AppDomain"/>.
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be unloaded.</param>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Clone(System.AppDomain)">
            <summary>
            Clones the specified <see cref="T:System.AppDomain"/>. The mandatory "creation" properties of the <paramref name="domain"/> are used to create the new instance of <see cref="T:System.AppDomain"/>.
            <para>The "friendly name" of the cloned <see cref="T:System.AppDomain"/> is a string representation of the random <c>GUID</c>.</para>
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be cloned.</param>
            <returns>The newly created <see cref="T:System.AppDomain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.GetStrongName(System.Reflection.Assembly)">
            <summary>
            Gets the strong name of the assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>Assembly strong name.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Clone(System.AppDomain,System.String,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
            <summary>
            Clones the specified <see cref="T:System.AppDomain"/>. The mandatory "creation" properties of the <paramref name="domain"/> are used to create the new instance of <see cref="T:System.AppDomain"/>.
            <para>The <paramref name="name"/> parameter is used as the "friendly name" for the cloned <see cref="T:System.AppDomain"/>.</para>
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be cloned.</param>
            <param name="name">The "friendly name" of the new <see cref="T:System.AppDomain"/> to be created.</param>
            <param name="permissions">The permissions.</param>
            <param name="fullyTrustedAssemblies">The fully trusted assemblies.</param>
            <returns>The newly created <see cref="T:System.AppDomain"/>.</returns>
        </member>
        <member name="T:CSScriptLibrary.Sandbox">
            <summary>
            Simple security helper class. This class is nothing else but a syntactic sugar.
            <para>
            <example>The following is an example of execution under .NET sandbox:
            <code>
            Sandbox.With(SecurityPermissionFlag.Execution)
                   .Execute(() =>
                            {
                                //call sandboxed actions
                            });
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="T:CSScriptLibrary.Sandbox.Action">
            <summary>
            Generic void/void delegate
            </summary>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With``1(``0,System.Action{``0})">
            <summary>
            Extension method. To assist with Fluent API.
            </summary>
            <param name="obj">The object that is a subject of Fluent invocation.</param>
            <param name="action">The action to be performed against object.</param>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.Execute(System.Security.PermissionSet,CSScriptLibrary.Sandbox.Action)">
            <summary>
            Extension method. Executes <see cref="T:System.Action"/> with the specified array of permissions
            </summary>
            <param name="permissions">The permissions set to be used for the execution.</param>
            <param name="action">The action to be executed.</param>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.IPermission[])">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="M:CSScriptLibrary.Sandbox.Execute(System.Security.PermissionSet,CSScriptLibrary.Sandbox.Action)"/>.
            </summary>
            <param name="permissions">The permissions.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.Permissions.SecurityPermissionFlag)">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="М:csscript.Sandbox.Execute"/>.
            </summary>
            <param name="permissionsFlag">The permissions flag. Can be combination of multiple values.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="T:CSScriptLibrary.PrintDelegate">
            <summary>
            Delegate to handle output from script
            </summary>
        </member>
        <member name="T:CSScriptLibrary.IsOutOfDateResolver">
            <summary>
            Delegate to determine if the script assembly is out of data and needs to be recompiled
            </summary>
            <param name="scriptSource">The script source.</param>
            <param name="scriptAssembly">The script assembly.</param>
            <returns>'true' if the script assembly is out of date.</returns>
        </member>
        <member name="T:CSScriptLibrary.BuildConfiguration">
            <summary>
            Type of the build (compile) configuration
            </summary>
        </member>
        <member name="F:CSScriptLibrary.BuildConfiguration.Debug">
            <summary>
            The typical Debug build configuration
            </summary>
        </member>
        <member name="F:CSScriptLibrary.BuildConfiguration.Release">
            <summary>
            The typical Release build configuration
            </summary>
        </member>
        <member name="T:CSScriptLibrary.MonoEvaluator">
            <summary>
            A wrapper class that encapsulates the functionality of the Mono.CSharp.Evaluator.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.Clone(System.Boolean)">
             <summary>
             Clones itself as <see cref="T:CSScriptLibrary.IEvaluator"/>. 
             <para>
             This method returns a freshly initialized copy of the <see cref="T:CSScriptLibrary.IEvaluator"/>. 
             The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies"/>.
             </para>
             <para>
             This method is a convenient technique when multiple <see cref="T:CSScriptLibrary.IEvaluator"/> instances  
             are required (e.g. for concurrent script evaluation).
             </para>
             </summary>
             <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLibrary.IEvaluator"/> 
             will be referenced in the cloned copy.</param>
             <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
             <example>
            <code>
             var eval1 = CSScript.MonoEvaluator.Clone();
             var eval2 = CSScript.MonoEvaluator.Clone();
             
             var sub = eval1.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a - b;
                                          }");
                                          
             var sum = eval2.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a + b;
                                          }");
                                          
             var result = sum(7, sub(4,2));
             </code>
             </example>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.CompilerSettings">
            <summary>
            Gets or sets the compiler settings.
            </summary>
            <value>The compiler settings.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.CompilingResult">
            <summary>
            Gets or sets the compiling result.
            </summary>
            <value>The compiling result.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.ThrowOnError">
            <summary>
            Gets or sets the flag indicating if the compilation error should throw an exception.
            </summary>
            <value>The throw on error.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies 
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.AutoResetEvaluatorOnError">
            <summary>
            Gets or sets a value indicating whether to reset <c>Mono.Evaluator</c> automatically after it fails
            to compile the code.
            <para>It is a work around for the <c>Mono.Evaluator</c> (v4.0.0.0), which cannot longer compile the valid C# code
            after the first compilation failure.</para>
            <para>This setting allows auto recreation (reset) of the actual <c>Mono.Evaluator</c> service.</para>
            </summary>
            <value>
            <c>true</c> if <c>Mono.Evaluator</c> is to be reset automatically; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.WarningsAsErrors">
            <summary>
            Gets or sets the warnings as errors.
            </summary>
            <value>The warnings as errors.</value>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.MonoEvaluator" /> class.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.IsDebugSymbolDefined">
            <summary>
            Gets or sets the flag for defining the conditional compiling symbol "DEBUG".
            </summary>
            <value>The flag indicating if the "DEBUG" symbol defined.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.Configuration">
            <summary>
            Gets or sets the build configuration.
            </summary>
            <value>The configuration value.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, affect of setting <c>DebugBuild</c> will always depend on the compiler implementation:
            <list type="bullet">
               <item><term>CodeDom</term><description>Fully supports. Generates degugging symbols (script can be debugged) and defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Mono</term><description>Partially supports. Defines <c>DEBUG</c> and <c>TRACE</c> conditional symbols</description> </item>
               <item><term>Roslyn</term><description>Doesn't supports at all.</description> </item>
            </list>
            </para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CSScriptLibrary.MonoEvaluator.IsTraceSymbolDefined">
            <summary>
            Gets or sets the flag for defining the conditional compiling symbol "TRACE".
            </summary>
            <value>The flag indicating if the "TRACE" symbol defined.</value>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating <see cref="T:Mono.CSharp.CompilerSettings"/>, 
            <see cref="P:CSScriptLibrary.MonoEvaluator.CompilingResult"/> and underlying compiling services. 
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with 
            <paramref name="referenceDomainAssemblies"/>.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLibrary.MonoEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)"/> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLibrary.IEvaluator"/>.</returns>
        </member>
        <member name="F:CSScriptLibrary.MonoEvaluator.IgnoreDomainAssembliesWithPrefixes">
            <summary>
            The name prefixes of the assemblies that will be ignored when <see cref="T:Mono.CSharp.CompilerSettings"/> and <see cref="P:CSScriptLibrary.MonoEvaluator.CompilingResult"/>
            references the loaded assemblies of the current AppDomain.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLibrary.IEvaluator"/> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.GetReferencedAssemblies">
            <summary>
            Returns set of referenced assemblies. 
            <para>
            Notre: the set of assemblies is get cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.MonoEvaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadFile(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.MonoEvaluator
                                      .LoadFile("calc.cs");
                                      
             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadCode``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> Because the interface alignment is a duck typing implementation the script class doesn't have to 
             inherit from <c>T</c>.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.MonoEvaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Gets referenced assemblies from the script code.
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadFile``1(System.String)">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.MonoEvaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");
                                  
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads (returns instance) the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.MonoEvaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");
            
             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads (returns instance) the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.MonoEvaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.MonoEvaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");
            
             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a non-typed <see cref="T:CSScriptLibrary.MethodDelegate"/></returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.MonoEvaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");
            
             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLibrary.MethodDelegate`1"/></returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.LoadDelegate``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads 
            the class to the current AppDomain.
            <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
            </summary>
             <example>
            <code>
            var Product = CSScript.MonoEvaluator
                                  .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                                 @"int Product(int a, int b)
                                                   {
                                                       return a * b;
                                                   }");
                                             
            int result = Product(3, 2);
            </code>
            </example>
            <param name="code">The C# code.</param>
            <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLibrary.IEvaluator.CompileCode(System.String)"/> but is allows you to define 
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.MonoEvaluator
                                      .CompileMethod(@"int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }")
                                      .CreateObject("*"); 
                                      
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.GetCompiledType(System.String)">
            <summary>
            Gets a type from the last Compile/Evaluate/Load call.
            </summary>
            <param name="type">The type name.</param>
            <returns>The type instance</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.CompileCode(System.String)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s). 
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.MonoEvaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");
                                                      
             dynamic script =  asm.CreateObject("*"); 
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.Evaluate(System.String)">
            <summary>
            Evaluates the specified C# statement and returns the result of the execution.
            </summary>
            <example>
            <code>
            string upperCaseText = (string)CSScript.MonoEvaluator.Evaluate("\"Hello\".ToUpper();");
            int sum = (int)CSScript.MonoEvaluator.Evaluate("1+2;");
            </code>
            </example>
            <param name="scriptText">The C# statement.</param>
            <returns>Result of the evaluation (execution).</returns>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.Run(System.String)">
            <summary>
            Evaluates the specified C# statement. The statement must be "void" (returning no result).
            </summary>
            <example>
            <code>
            CSScript.MonoEvaluator.Run("using System;");
            CSScript.MonoEvaluator.Run("Console.WriteLine(\"Hello World!\");");
            </code>
            </example>
            <param name="scriptText">The C# statement.</param>
        </member>
        <member name="M:CSScriptLibrary.MonoEvaluator.GetService">
            <summary>
            Gets the underlying <see cref="T:Mono.CSharp.Evaluator"/>.It is the actual Mono "compiler as service".
            </summary>
            <returns>Instance of <see cref="T:Mono.CSharp.Evaluator"/>.</returns>
        </member>
        <member name="T:CSScriptLibrary.CompilingResult">
            <summary>
            Custom implementation of <see cref="T:Mono.CSharp.ReportPrinter"/> required by
            <see cref="N:Mono.CSharp"/> API model for handling (reporting) compilation errors.
            <para><see cref="N:Mono.CSharp"/> default compiling error reporting (e.g. <see cref="T:Mono.CSharp.ConsoleReportPrinter"/>)
            is not dev-friendly, thus <c>CompilingResult</c> is acting as an adapter bringing the Mono API close to the
            traditional CodeDOM error reporting model.</para>
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CompilingResult.Errors">
            <summary>
            The collection of compiling errors.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CompilingResult.Warnings">
            <summary>
            The collection of compiling warnings.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CompilingResult.HasErrors">
            <summary>
            Indicates if the last compilation yielded any errors.
            </summary>
            <value>If set to <c>true</c> indicates presence of compilation error(s).</value>
        </member>
        <member name="P:CSScriptLibrary.CompilingResult.HasWarnings">
            <summary>
            Indicates if the last compilation yielded any warnings.
            </summary>
            <value>If set to <c>true</c> indicates presence of compilation warning(s).</value>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.CreateException(System.Boolean)">
            <summary>
            Creates the <see cref="T:System.Exception"/> containing combined error information.
            Optionally warnings can also be included in the exception info.
            </summary>
            <param name="hideCompilerWarnings">The flag indicating if compiler warnings should be included in the error (<see cref="T:System.Exception"/>) info.</param>
            <returns>Instance of the <see cref="T:csscript.CompilerException"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.Reset">
            <summary>
            Clears all errors and warnings.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.Print(Mono.CSharp.AbstractMessage,System.Boolean)">
            <summary>
            Handles compilation event message.
            </summary>
            <param name="msg">The compilation event message.</param>
            <param name="showFullPath">if set to <c>true</c> [show full path].</param>
        </member>
        <member name="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1">
            <summary>
                A utility class which converts an object to specified interface T. The object does
                not necessarily need to implement the interface formally.
            </summary>
            <typeparam name="T">Interface definition to convert to.</typeparam>
            <remarks>
            <para>
                Class Information:
                <list type="bullet">
                    <item name="authors">Authors: Ruben Hakopian</item>
                    <item name="date">March 2009</item>
                    <item name="originalURL">http://rubenhak.com/?p=167</item>
                </list>
            </para>
            </remarks>
        </member>
        <member name="F:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1._proxyCache">
            <summary>
            Represents a map from a object type to the type of its proxy class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.As(System.Object,System.String[])">
            <summary>
            Converts specified object to an another object which implements interface T.
            </summary>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency assemblies
            the interface depends in. </param>
            <returns>Converted object if succeeded; null otherwise.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CheckSourceObject(System.Type,System.Type,System.String[])">
            <summary>
            Checks if the source type can be convert to destination interface type.
            </summary>
            <param name="interfaceType">The source type to convert from.</param>
            <param name="sourceType">The destination interface type to convert to.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies
            the interface depends in. </param>
            <returns>true if conversion can be performed; false otherwise</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CastToInterface(System.Type,System.Object,System.String[])">
            <summary>
            Creates an instance of an proxy object which implements interface T and wraps specified object.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency assemblies
            the interface depends in. </param>
            <returns>Instance of the proxy object.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.BuildProxyClass(System.Type,System.Type,System.Boolean,System.String[])">
            <summary>
            Builds the proxy class for specified interface and source types.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <param name="injectNamespace">if set to <c>true</c> the <c>CSScriptLibrary.DynamicTypes</c>
            will be injected the proxy class name.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency assemblies
            the interface depends in.</param>
            <returns>Type definition for proxy class.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.BuildProxyClassCode(System.Type,System.Type,System.String@,System.Boolean)">
            <summary>
            Added by Oleg Shilo
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClass(System.Type,System.Type,System.Boolean)">
            <summary>
            Generates the proxy class.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <param name="injectNamespace">if set to <c>true</c> the <c>CSScriptLibrary.DynamicTypes</c>
            will be injected the proxy class name.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassProperties(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class properties.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassMethods(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class methods.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassEvents(System.CodeDom.CodeTypeDeclaration,System.CodeDom.CodeConstructor,System.Type,System.Type)">
            <summary>
            Generates the proxy class events.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="constructor">The generated class constructor.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="T:CSScriptLibraryExtensionMethods">
            <summary>
            Method extensions for
            </summary>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetScriptName(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script) and returns full path of the script file
            used to compile the assembly. The analysis is based on the fact that script assembly (in hosing scenarios) is always
            stamped with <see cref="T:System.Reflection.AssemblyDescriptionAttribute"/>, which contains name of the script file the
            assembly was compiled from.
            <para>The format of the description </para>
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	Script file path if the specified assembly is a script assembly otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.SingletonExecute(System.Reflection.Assembly,System.Action,System.Action)">
            <summary>
            Executes an action as a "singleton". 
            <para>This extension method takes a delegate and executes it in the context of the claimed named mutex. It doesn't execute the action and
            returns immediately if any previously invoked action from the same context is still in progress: mutex is not released.</para>
            <para>Mutex name uniqueness is based on the assembly identity (location).</para>
            <code>
            //application
            class Program
            {
                static void Main()
                {
                    Assembly.GetExecutingAssembly()
                            .SingletonExecute(main, 
                                              ()=>MessageBox.Show("Another instance is already running."));
                }
            
                static void main()
                {
                    //business logic
                }
            }
            
            //script
            var script = @"using System.Reflection;
                           public static void DoWork()
                           {
                               Assembly.GetExecutingAssembly()
                                       .SingletonExecute(() => 
                                       {  
                                           //business logic;
                                       }, 
                                       () => Console.WriteLine(""another instance of 'script' is being executed""));
                           }";
            
            var DoWork = CSScript.LoadMethod(script).GetStaticMethod();
            Task.Run(DoWork);
            Task.Run(DoWork);
            Task.Run(DoWork);
            </code>
            </summary>
            <param name="assembly">The assembly.</param>
            <param name="action">The action.</param>
            <param name="onBusyAction">The on busy action.</param>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetHelper(System.Reflection.Assembly)">
            <summary>
            Constructs and returns an instance of CSScriptLibrary.AsmHelper class from the underlying Assembly.
            </summary>
            <returns>CSScriptLibrary.AsmHelper</returns>
            <param name="obj">Instance of the type to be extended</param>
            <returns>CSScriptLibrary.AsmHelper</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <para>
            GetStaticMethod("Calc.Sum", 0, 0)
            </para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod``1(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <para>
            GetStaticMethod("Calc.Sum", 0, 0)
            </para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethodWithArgs(System.Reflection.Assembly,System.String,System.Type[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethodWithArgs``1(System.Reflection.Assembly,System.String,System.Type[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly)">
             <summary>
             <param name="obj">Instance of the type to be extended</param>
             Specialized version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
             underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            
             Use this method when script assembly contains only one single type with one method.
             </summary>
             <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod``1(System.Reflection.Assembly)">
             <summary>
             <param name="obj">Instance of the type to be extended</param>
             Specialized version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
             underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            
             Use this method when script assembly contains only one single type with one method.
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryCreateObject(System.Reflection.Assembly,System.String)">
             <summary>
             Attempts to create instance of a class from underlying assembly.
             </summary>
             <param name="obj">Instance of the type to be extended</param>
             <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
             You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
             <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.CreateObject(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.CreateInstance(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Creates the instance of the Type.
            <para>It is nothing else but a more convenient version of Assembly. CreateInstance(string typeName, bool ignoreCase, BindingFlags...) method.
            It's objective is to simplify invoking the constructors with parameters.
            </para>
            </summary>
            <param name="assembly">The assembly.</param>
            <param name="typeName">Name of the type.</param>
            <param name="args">The arguments.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLife(System.MarshalByRefObject,System.TimeSpan)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <param name="obj">The instance created in the remote AppDomain.</param>
            <param name="renewalTime">The renewal time.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLifeFromMinutes(System.Object,System.Int32)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <param name="obj">The instance created in the remote AppDomain.</param>
            <param name="minutes">The renewal time in minutes.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLifeFromMinutes``1(CSScriptLibrary.MethodDelegate{``0},System.Int32)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <typeparam name="T">The delegate return type.</typeparam>
            <param name="method">The instance of the <see cref="T:CSScriptLibrary.MethodDelegate`1"/> created in the remote AppDomain.</param>
            <param name="minutes">The renewal time in minutes.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
            <exception cref="T:System.Exception">MethodDelegate doesn't seem to be owned by the transparent proxy connected to the remote AppDomain object. +
                             You don't need to extend life local objects.</exception>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLifeFromMinutes(CSScriptLibrary.MethodDelegate,System.Int32)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <param name="method">The instance of the <see cref="T:CSScriptLibrary.MethodDelegate"/> created in the remote AppDomain.</param>
            <param name="minutes">The renewal time in minutes.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
            <exception cref="T:System.Exception">MethodDelegate doesn't seem to be owned by the transparent proxy connected to the remote AppDomain object. +
                             You don't need to extend life local objects.</exception>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.String[])">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.Boolean,System.String[])">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all non-GAC loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.Boolean,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all non-GAC loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
    </members>
</doc>
